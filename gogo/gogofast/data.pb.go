// Code generated by protoc-gen-gogo.
// source: data.proto
// DO NOT EDIT!

/*
	Package gogofast is a generated protocol buffer package.

	It is generated from these files:
		data.proto

	It has these top-level messages:
		GoGoFastBasicMemInfo
		GoGoFastMemInfo
		GoGoFastMessage
		GoGoFastRedditAccount
		GoGoFastAccountData
		GoGoFastCPUInfo
		GoGoFastCPU
*/
package gogofast

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
const _ = proto.ProtoPackageIsVersion1

type GoGoFastBasicMemInfo struct {
	MemTotal     int64 `protobuf:"varint,1,opt,name=MemTotal,json=memTotal,proto3" json:"MemTotal,omitempty"`
	MemFree      int64 `protobuf:"varint,2,opt,name=MemFree,json=memFree,proto3" json:"MemFree,omitempty"`
	MemAvailable int64 `protobuf:"varint,3,opt,name=MemAvailable,json=memAvailable,proto3" json:"MemAvailable,omitempty"`
	Buffers      int64 `protobuf:"varint,4,opt,name=Buffers,json=buffers,proto3" json:"Buffers,omitempty"`
	Cached       int64 `protobuf:"varint,5,opt,name=Cached,json=cached,proto3" json:"Cached,omitempty"`
	SwapCached   int64 `protobuf:"varint,6,opt,name=SwapCached,json=swapCached,proto3" json:"SwapCached,omitempty"`
	SwapTotal    int64 `protobuf:"varint,7,opt,name=SwapTotal,json=swapTotal,proto3" json:"SwapTotal,omitempty"`
	SwapFree     int64 `protobuf:"varint,8,opt,name=SwapFree,json=swapFree,proto3" json:"SwapFree,omitempty"`
}

func (m *GoGoFastBasicMemInfo) Reset()                    { *m = GoGoFastBasicMemInfo{} }
func (m *GoGoFastBasicMemInfo) String() string            { return proto.CompactTextString(m) }
func (*GoGoFastBasicMemInfo) ProtoMessage()               {}
func (*GoGoFastBasicMemInfo) Descriptor() ([]byte, []int) { return fileDescriptorData, []int{0} }

type GoGoFastMemInfo struct {
	MemTotal          int64 `protobuf:"varint,1,opt,name=MemTotal,json=memTotal,proto3" json:"MemTotal,omitempty"`
	MemFree           int64 `protobuf:"varint,2,opt,name=MemFree,json=memFree,proto3" json:"MemFree,omitempty"`
	MemAvailable      int64 `protobuf:"varint,3,opt,name=MemAvailable,json=memAvailable,proto3" json:"MemAvailable,omitempty"`
	Buffers           int64 `protobuf:"varint,4,opt,name=Buffers,json=buffers,proto3" json:"Buffers,omitempty"`
	Cached            int64 `protobuf:"varint,5,opt,name=Cached,json=cached,proto3" json:"Cached,omitempty"`
	SwapCached        int64 `protobuf:"varint,6,opt,name=SwapCached,json=swapCached,proto3" json:"SwapCached,omitempty"`
	Active            int64 `protobuf:"varint,7,opt,name=Active,json=active,proto3" json:"Active,omitempty"`
	Inactive          int64 `protobuf:"varint,8,opt,name=Inactive,json=inactive,proto3" json:"Inactive,omitempty"`
	ActiveAnon        int64 `protobuf:"varint,9,opt,name=ActiveAnon,json=activeAnon,proto3" json:"ActiveAnon,omitempty"`
	InactiveAnon      int64 `protobuf:"varint,10,opt,name=InactiveAnon,json=inactiveAnon,proto3" json:"InactiveAnon,omitempty"`
	ActiveFile        int64 `protobuf:"varint,11,opt,name=ActiveFile,json=activeFile,proto3" json:"ActiveFile,omitempty"`
	InactiveFile      int64 `protobuf:"varint,12,opt,name=InactiveFile,json=inactiveFile,proto3" json:"InactiveFile,omitempty"`
	Unevictable       int64 `protobuf:"varint,13,opt,name=Unevictable,json=unevictable,proto3" json:"Unevictable,omitempty"`
	Mlocked           int64 `protobuf:"varint,14,opt,name=Mlocked,json=mlocked,proto3" json:"Mlocked,omitempty"`
	SwapTotal         int64 `protobuf:"varint,15,opt,name=SwapTotal,json=swapTotal,proto3" json:"SwapTotal,omitempty"`
	SwapFree          int64 `protobuf:"varint,16,opt,name=SwapFree,json=swapFree,proto3" json:"SwapFree,omitempty"`
	Dirty             int64 `protobuf:"varint,17,opt,name=Dirty,json=dirty,proto3" json:"Dirty,omitempty"`
	Writeback         int64 `protobuf:"varint,18,opt,name=Writeback,json=writeback,proto3" json:"Writeback,omitempty"`
	AnonPages         int64 `protobuf:"varint,19,opt,name=AnonPages,json=anonPages,proto3" json:"AnonPages,omitempty"`
	Mapped            int64 `protobuf:"varint,20,opt,name=Mapped,json=mapped,proto3" json:"Mapped,omitempty"`
	Shmem             int64 `protobuf:"varint,21,opt,name=Shmem,json=shmem,proto3" json:"Shmem,omitempty"`
	Slab              int64 `protobuf:"varint,22,opt,name=Slab,json=slab,proto3" json:"Slab,omitempty"`
	SReclaimable      int64 `protobuf:"varint,23,opt,name=SReclaimable,json=sReclaimable,proto3" json:"SReclaimable,omitempty"`
	SUnreclaim        int64 `protobuf:"varint,24,opt,name=SUnreclaim,json=sUnreclaim,proto3" json:"SUnreclaim,omitempty"`
	KernelStack       int64 `protobuf:"varint,25,opt,name=KernelStack,json=kernelStack,proto3" json:"KernelStack,omitempty"`
	NFSUnstable       int64 `protobuf:"varint,26,opt,name=NFSUnstable,json=nFSUnstable,proto3" json:"NFSUnstable,omitempty"`
	Bounce            int64 `protobuf:"varint,27,opt,name=Bounce,json=bounce,proto3" json:"Bounce,omitempty"`
	WritebackTmp      int64 `protobuf:"varint,28,opt,name=WritebackTmp,json=writebackTmp,proto3" json:"WritebackTmp,omitempty"`
	CommitLimit       int64 `protobuf:"varint,29,opt,name=CommitLimit,json=commitLimit,proto3" json:"CommitLimit,omitempty"`
	VmallocTotal      int64 `protobuf:"varint,30,opt,name=VmallocTotal,json=vmallocTotal,proto3" json:"VmallocTotal,omitempty"`
	VmallocUsed       int64 `protobuf:"varint,31,opt,name=VmallocUsed,json=vmallocUsed,proto3" json:"VmallocUsed,omitempty"`
	VmallocChunk      int64 `protobuf:"varint,32,opt,name=VmallocChunk,json=vmallocChunk,proto3" json:"VmallocChunk,omitempty"`
	HardwareCorrupted int64 `protobuf:"varint,33,opt,name=HardwareCorrupted,json=hardwareCorrupted,proto3" json:"HardwareCorrupted,omitempty"`
	AnonHugePages     int64 `protobuf:"varint,34,opt,name=AnonHugePages,json=anonHugePages,proto3" json:"AnonHugePages,omitempty"`
	HugePagesTotal    int64 `protobuf:"varint,35,opt,name=HugePagesTotal,json=hugePagesTotal,proto3" json:"HugePagesTotal,omitempty"`
	HugePagesFree     int64 `protobuf:"varint,36,opt,name=HugePagesFree,json=hugePagesFree,proto3" json:"HugePagesFree,omitempty"`
	HugePagesRsvd     int64 `protobuf:"varint,37,opt,name=HugePagesRsvd,json=hugePagesRsvd,proto3" json:"HugePagesRsvd,omitempty"`
	Hugepagesize      int64 `protobuf:"varint,38,opt,name=Hugepagesize,json=hugepagesize,proto3" json:"Hugepagesize,omitempty"`
	DirectMap4K       int64 `protobuf:"varint,39,opt,name=DirectMap4k,json=directMap4k,proto3" json:"DirectMap4k,omitempty"`
	DirectMap2M       int64 `protobuf:"varint,40,opt,name=DirectMap2M,json=directMap2M,proto3" json:"DirectMap2M,omitempty"`
}

func (m *GoGoFastMemInfo) Reset()                    { *m = GoGoFastMemInfo{} }
func (m *GoGoFastMemInfo) String() string            { return proto.CompactTextString(m) }
func (*GoGoFastMemInfo) ProtoMessage()               {}
func (*GoGoFastMemInfo) Descriptor() ([]byte, []int) { return fileDescriptorData, []int{1} }

type GoGoFastMessage struct {
	ID     []byte `protobuf:"bytes,1,opt,name=ID,json=iD,proto3" json:"ID,omitempty"`
	DestID uint32 `protobuf:"varint,2,opt,name=DestID,json=destID,proto3" json:"DestID,omitempty"`
	Type   int32  `protobuf:"varint,3,opt,name=Type,json=type,proto3" json:"Type,omitempty"`
	Kind   int32  `protobuf:"varint,4,opt,name=Kind,json=kind,proto3" json:"Kind,omitempty"`
	Data   []byte `protobuf:"bytes,5,opt,name=Data,json=data,proto3" json:"Data,omitempty"`
}

func (m *GoGoFastMessage) Reset()                    { *m = GoGoFastMessage{} }
func (m *GoGoFastMessage) String() string            { return proto.CompactTextString(m) }
func (*GoGoFastMessage) ProtoMessage()               {}
func (*GoGoFastMessage) Descriptor() ([]byte, []int) { return fileDescriptorData, []int{2} }

type GoGoFastRedditAccount struct {
	ID   string               `protobuf:"bytes,1,opt,name=ID,json=iD,proto3" json:"ID,omitempty"`
	Name string               `protobuf:"bytes,2,opt,name=Name,json=name,proto3" json:"Name,omitempty"`
	Kind string               `protobuf:"bytes,3,opt,name=Kind,json=kind,proto3" json:"Kind,omitempty"`
	Data *GoGoFastAccountData `protobuf:"bytes,4,opt,name=Data,json=data" json:"Data,omitempty"`
}

func (m *GoGoFastRedditAccount) Reset()                    { *m = GoGoFastRedditAccount{} }
func (m *GoGoFastRedditAccount) String() string            { return proto.CompactTextString(m) }
func (*GoGoFastRedditAccount) ProtoMessage()               {}
func (*GoGoFastRedditAccount) Descriptor() ([]byte, []int) { return fileDescriptorData, []int{3} }

func (m *GoGoFastRedditAccount) GetData() *GoGoFastAccountData {
	if m != nil {
		return m.Data
	}
	return nil
}

type GoGoFastAccountData struct {
	CommentKarma int64  `protobuf:"varint,1,opt,name=CommentKarma,json=commentKarma,proto3" json:"CommentKarma,omitempty"`
	HasMail      bool   `protobuf:"varint,2,opt,name=HasMail,json=hasMail,proto3" json:"HasMail,omitempty"`
	HasModMail   bool   `protobuf:"varint,3,opt,name=HasModMail,json=hasModMail,proto3" json:"HasModMail,omitempty"`
	ID           string `protobuf:"bytes,4,opt,name=ID,json=iD,proto3" json:"ID,omitempty"`
	InboxCount   int64  `protobuf:"varint,5,opt,name=InboxCount,json=inboxCount,proto3" json:"InboxCount,omitempty"`
	IsFriend     bool   `protobuf:"varint,6,opt,name=IsFriend,json=isFriend,proto3" json:"IsFriend,omitempty"`
	IsGold       bool   `protobuf:"varint,7,opt,name=IsGold,json=isGold,proto3" json:"IsGold,omitempty"`
	LinkKarma    int64  `protobuf:"varint,8,opt,name=LinkKarma,json=linkKarma,proto3" json:"LinkKarma,omitempty"`
	ModHash      string `protobuf:"bytes,9,opt,name=ModHash,json=modHash,proto3" json:"ModHash,omitempty"`
	Name         string `protobuf:"bytes,10,opt,name=Name,json=name,proto3" json:"Name,omitempty"`
	Over18       bool   `protobuf:"varint,11,opt,name=Over18,json=over18,proto3" json:"Over18,omitempty"`
}

func (m *GoGoFastAccountData) Reset()                    { *m = GoGoFastAccountData{} }
func (m *GoGoFastAccountData) String() string            { return proto.CompactTextString(m) }
func (*GoGoFastAccountData) ProtoMessage()               {}
func (*GoGoFastAccountData) Descriptor() ([]byte, []int) { return fileDescriptorData, []int{4} }

type GoGoFastCPUInfo struct {
	CPUs []*GoGoFastCPU `protobuf:"bytes,1,rep,name=CPUs,json=cPUs" json:"CPUs,omitempty"`
}

func (m *GoGoFastCPUInfo) Reset()                    { *m = GoGoFastCPUInfo{} }
func (m *GoGoFastCPUInfo) String() string            { return proto.CompactTextString(m) }
func (*GoGoFastCPUInfo) ProtoMessage()               {}
func (*GoGoFastCPUInfo) Descriptor() ([]byte, []int) { return fileDescriptorData, []int{5} }

func (m *GoGoFastCPUInfo) GetCPUs() []*GoGoFastCPU {
	if m != nil {
		return m.CPUs
	}
	return nil
}

type GoGoFastCPU struct {
	Processor       int32   `protobuf:"varint,1,opt,name=Processor,json=processor,proto3" json:"Processor,omitempty"`
	VendorID        string  `protobuf:"bytes,2,opt,name=VendorID,json=vendorID,proto3" json:"VendorID,omitempty"`
	CPUFamily       string  `protobuf:"bytes,3,opt,name=CPUFamily,json=cPUFamily,proto3" json:"CPUFamily,omitempty"`
	Model           string  `protobuf:"bytes,4,opt,name=Model,json=model,proto3" json:"Model,omitempty"`
	ModelName       string  `protobuf:"bytes,5,opt,name=ModelName,json=modelName,proto3" json:"ModelName,omitempty"`
	Stepping        string  `protobuf:"bytes,6,opt,name=Stepping,json=stepping,proto3" json:"Stepping,omitempty"`
	Microcode       string  `protobuf:"bytes,7,opt,name=Microcode,json=microcode,proto3" json:"Microcode,omitempty"`
	CPUMHz          float32 `protobuf:"fixed32,8,opt,name=CPUMHz,json=cPUMHz,proto3" json:"CPUMHz,omitempty"`
	CacheSize       string  `protobuf:"bytes,9,opt,name=CacheSize,json=cacheSize,proto3" json:"CacheSize,omitempty"`
	PhysicalID      int32   `protobuf:"varint,10,opt,name=PhysicalID,json=physicalID,proto3" json:"PhysicalID,omitempty"`
	Siblings        int32   `protobuf:"varint,11,opt,name=Siblings,json=siblings,proto3" json:"Siblings,omitempty"`
	CoreID          int32   `protobuf:"varint,12,opt,name=CoreID,json=coreID,proto3" json:"CoreID,omitempty"`
	CPUCores        int32   `protobuf:"varint,13,opt,name=CPUCores,json=cPUCores,proto3" json:"CPUCores,omitempty"`
	ApicID          int32   `protobuf:"varint,14,opt,name=ApicID,json=apicID,proto3" json:"ApicID,omitempty"`
	InitialApicID   int32   `protobuf:"varint,15,opt,name=InitialApicID,json=initialApicID,proto3" json:"InitialApicID,omitempty"`
	FPU             string  `protobuf:"bytes,16,opt,name=FPU,json=fPU,proto3" json:"FPU,omitempty"`
	FPUException    string  `protobuf:"bytes,17,opt,name=FPUException,json=fPUException,proto3" json:"FPUException,omitempty"`
	CPUIDLevel      string  `protobuf:"bytes,18,opt,name=CPUIDLevel,json=cPUIDLevel,proto3" json:"CPUIDLevel,omitempty"`
	WP              string  `protobuf:"bytes,19,opt,name=WP,json=wP,proto3" json:"WP,omitempty"`
	Flags           string  `protobuf:"bytes,21,opt,name=Flags,json=flags,proto3" json:"Flags,omitempty"`
	BogoMIPS        float32 `protobuf:"fixed32,22,opt,name=BogoMIPS,json=bogoMIPS,proto3" json:"BogoMIPS,omitempty"`
	CLFlushSize     string  `protobuf:"bytes,23,opt,name=CLFlushSize,json=cLFlushSize,proto3" json:"CLFlushSize,omitempty"`
	CacheAlignment  string  `protobuf:"bytes,24,opt,name=CacheAlignment,json=cacheAlignment,proto3" json:"CacheAlignment,omitempty"`
	AddressSizes    string  `protobuf:"bytes,25,opt,name=AddressSizes,json=addressSizes,proto3" json:"AddressSizes,omitempty"`
	PowerManagement string  `protobuf:"bytes,26,opt,name=PowerManagement,json=powerManagement,proto3" json:"PowerManagement,omitempty"`
}

func (m *GoGoFastCPU) Reset()                    { *m = GoGoFastCPU{} }
func (m *GoGoFastCPU) String() string            { return proto.CompactTextString(m) }
func (*GoGoFastCPU) ProtoMessage()               {}
func (*GoGoFastCPU) Descriptor() ([]byte, []int) { return fileDescriptorData, []int{6} }

func init() {
	proto.RegisterType((*GoGoFastBasicMemInfo)(nil), "protobuf.GoGoFastBasicMemInfo")
	proto.RegisterType((*GoGoFastMemInfo)(nil), "protobuf.GoGoFastMemInfo")
	proto.RegisterType((*GoGoFastMessage)(nil), "protobuf.GoGoFastMessage")
	proto.RegisterType((*GoGoFastRedditAccount)(nil), "protobuf.GoGoFastRedditAccount")
	proto.RegisterType((*GoGoFastAccountData)(nil), "protobuf.GoGoFastAccountData")
	proto.RegisterType((*GoGoFastCPUInfo)(nil), "protobuf.GoGoFastCPUInfo")
	proto.RegisterType((*GoGoFastCPU)(nil), "protobuf.GoGoFastCPU")
}
func (m *GoGoFastBasicMemInfo) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *GoGoFastBasicMemInfo) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MemTotal != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintData(data, i, uint64(m.MemTotal))
	}
	if m.MemFree != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintData(data, i, uint64(m.MemFree))
	}
	if m.MemAvailable != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintData(data, i, uint64(m.MemAvailable))
	}
	if m.Buffers != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintData(data, i, uint64(m.Buffers))
	}
	if m.Cached != 0 {
		data[i] = 0x28
		i++
		i = encodeVarintData(data, i, uint64(m.Cached))
	}
	if m.SwapCached != 0 {
		data[i] = 0x30
		i++
		i = encodeVarintData(data, i, uint64(m.SwapCached))
	}
	if m.SwapTotal != 0 {
		data[i] = 0x38
		i++
		i = encodeVarintData(data, i, uint64(m.SwapTotal))
	}
	if m.SwapFree != 0 {
		data[i] = 0x40
		i++
		i = encodeVarintData(data, i, uint64(m.SwapFree))
	}
	return i, nil
}

func (m *GoGoFastMemInfo) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *GoGoFastMemInfo) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MemTotal != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintData(data, i, uint64(m.MemTotal))
	}
	if m.MemFree != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintData(data, i, uint64(m.MemFree))
	}
	if m.MemAvailable != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintData(data, i, uint64(m.MemAvailable))
	}
	if m.Buffers != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintData(data, i, uint64(m.Buffers))
	}
	if m.Cached != 0 {
		data[i] = 0x28
		i++
		i = encodeVarintData(data, i, uint64(m.Cached))
	}
	if m.SwapCached != 0 {
		data[i] = 0x30
		i++
		i = encodeVarintData(data, i, uint64(m.SwapCached))
	}
	if m.Active != 0 {
		data[i] = 0x38
		i++
		i = encodeVarintData(data, i, uint64(m.Active))
	}
	if m.Inactive != 0 {
		data[i] = 0x40
		i++
		i = encodeVarintData(data, i, uint64(m.Inactive))
	}
	if m.ActiveAnon != 0 {
		data[i] = 0x48
		i++
		i = encodeVarintData(data, i, uint64(m.ActiveAnon))
	}
	if m.InactiveAnon != 0 {
		data[i] = 0x50
		i++
		i = encodeVarintData(data, i, uint64(m.InactiveAnon))
	}
	if m.ActiveFile != 0 {
		data[i] = 0x58
		i++
		i = encodeVarintData(data, i, uint64(m.ActiveFile))
	}
	if m.InactiveFile != 0 {
		data[i] = 0x60
		i++
		i = encodeVarintData(data, i, uint64(m.InactiveFile))
	}
	if m.Unevictable != 0 {
		data[i] = 0x68
		i++
		i = encodeVarintData(data, i, uint64(m.Unevictable))
	}
	if m.Mlocked != 0 {
		data[i] = 0x70
		i++
		i = encodeVarintData(data, i, uint64(m.Mlocked))
	}
	if m.SwapTotal != 0 {
		data[i] = 0x78
		i++
		i = encodeVarintData(data, i, uint64(m.SwapTotal))
	}
	if m.SwapFree != 0 {
		data[i] = 0x80
		i++
		data[i] = 0x1
		i++
		i = encodeVarintData(data, i, uint64(m.SwapFree))
	}
	if m.Dirty != 0 {
		data[i] = 0x88
		i++
		data[i] = 0x1
		i++
		i = encodeVarintData(data, i, uint64(m.Dirty))
	}
	if m.Writeback != 0 {
		data[i] = 0x90
		i++
		data[i] = 0x1
		i++
		i = encodeVarintData(data, i, uint64(m.Writeback))
	}
	if m.AnonPages != 0 {
		data[i] = 0x98
		i++
		data[i] = 0x1
		i++
		i = encodeVarintData(data, i, uint64(m.AnonPages))
	}
	if m.Mapped != 0 {
		data[i] = 0xa0
		i++
		data[i] = 0x1
		i++
		i = encodeVarintData(data, i, uint64(m.Mapped))
	}
	if m.Shmem != 0 {
		data[i] = 0xa8
		i++
		data[i] = 0x1
		i++
		i = encodeVarintData(data, i, uint64(m.Shmem))
	}
	if m.Slab != 0 {
		data[i] = 0xb0
		i++
		data[i] = 0x1
		i++
		i = encodeVarintData(data, i, uint64(m.Slab))
	}
	if m.SReclaimable != 0 {
		data[i] = 0xb8
		i++
		data[i] = 0x1
		i++
		i = encodeVarintData(data, i, uint64(m.SReclaimable))
	}
	if m.SUnreclaim != 0 {
		data[i] = 0xc0
		i++
		data[i] = 0x1
		i++
		i = encodeVarintData(data, i, uint64(m.SUnreclaim))
	}
	if m.KernelStack != 0 {
		data[i] = 0xc8
		i++
		data[i] = 0x1
		i++
		i = encodeVarintData(data, i, uint64(m.KernelStack))
	}
	if m.NFSUnstable != 0 {
		data[i] = 0xd0
		i++
		data[i] = 0x1
		i++
		i = encodeVarintData(data, i, uint64(m.NFSUnstable))
	}
	if m.Bounce != 0 {
		data[i] = 0xd8
		i++
		data[i] = 0x1
		i++
		i = encodeVarintData(data, i, uint64(m.Bounce))
	}
	if m.WritebackTmp != 0 {
		data[i] = 0xe0
		i++
		data[i] = 0x1
		i++
		i = encodeVarintData(data, i, uint64(m.WritebackTmp))
	}
	if m.CommitLimit != 0 {
		data[i] = 0xe8
		i++
		data[i] = 0x1
		i++
		i = encodeVarintData(data, i, uint64(m.CommitLimit))
	}
	if m.VmallocTotal != 0 {
		data[i] = 0xf0
		i++
		data[i] = 0x1
		i++
		i = encodeVarintData(data, i, uint64(m.VmallocTotal))
	}
	if m.VmallocUsed != 0 {
		data[i] = 0xf8
		i++
		data[i] = 0x1
		i++
		i = encodeVarintData(data, i, uint64(m.VmallocUsed))
	}
	if m.VmallocChunk != 0 {
		data[i] = 0x80
		i++
		data[i] = 0x2
		i++
		i = encodeVarintData(data, i, uint64(m.VmallocChunk))
	}
	if m.HardwareCorrupted != 0 {
		data[i] = 0x88
		i++
		data[i] = 0x2
		i++
		i = encodeVarintData(data, i, uint64(m.HardwareCorrupted))
	}
	if m.AnonHugePages != 0 {
		data[i] = 0x90
		i++
		data[i] = 0x2
		i++
		i = encodeVarintData(data, i, uint64(m.AnonHugePages))
	}
	if m.HugePagesTotal != 0 {
		data[i] = 0x98
		i++
		data[i] = 0x2
		i++
		i = encodeVarintData(data, i, uint64(m.HugePagesTotal))
	}
	if m.HugePagesFree != 0 {
		data[i] = 0xa0
		i++
		data[i] = 0x2
		i++
		i = encodeVarintData(data, i, uint64(m.HugePagesFree))
	}
	if m.HugePagesRsvd != 0 {
		data[i] = 0xa8
		i++
		data[i] = 0x2
		i++
		i = encodeVarintData(data, i, uint64(m.HugePagesRsvd))
	}
	if m.Hugepagesize != 0 {
		data[i] = 0xb0
		i++
		data[i] = 0x2
		i++
		i = encodeVarintData(data, i, uint64(m.Hugepagesize))
	}
	if m.DirectMap4K != 0 {
		data[i] = 0xb8
		i++
		data[i] = 0x2
		i++
		i = encodeVarintData(data, i, uint64(m.DirectMap4K))
	}
	if m.DirectMap2M != 0 {
		data[i] = 0xc0
		i++
		data[i] = 0x2
		i++
		i = encodeVarintData(data, i, uint64(m.DirectMap2M))
	}
	return i, nil
}

func (m *GoGoFastMessage) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *GoGoFastMessage) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ID) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintData(data, i, uint64(len(m.ID)))
		i += copy(data[i:], m.ID)
	}
	if m.DestID != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintData(data, i, uint64(m.DestID))
	}
	if m.Type != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintData(data, i, uint64(m.Type))
	}
	if m.Kind != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintData(data, i, uint64(m.Kind))
	}
	if len(m.Data) > 0 {
		data[i] = 0x2a
		i++
		i = encodeVarintData(data, i, uint64(len(m.Data)))
		i += copy(data[i:], m.Data)
	}
	return i, nil
}

func (m *GoGoFastRedditAccount) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *GoGoFastRedditAccount) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ID) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintData(data, i, uint64(len(m.ID)))
		i += copy(data[i:], m.ID)
	}
	if len(m.Name) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintData(data, i, uint64(len(m.Name)))
		i += copy(data[i:], m.Name)
	}
	if len(m.Kind) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintData(data, i, uint64(len(m.Kind)))
		i += copy(data[i:], m.Kind)
	}
	if m.Data != nil {
		data[i] = 0x22
		i++
		i = encodeVarintData(data, i, uint64(m.Data.Size()))
		n1, err := m.Data.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	return i, nil
}

func (m *GoGoFastAccountData) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *GoGoFastAccountData) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CommentKarma != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintData(data, i, uint64(m.CommentKarma))
	}
	if m.HasMail {
		data[i] = 0x10
		i++
		if m.HasMail {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.HasModMail {
		data[i] = 0x18
		i++
		if m.HasModMail {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if len(m.ID) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintData(data, i, uint64(len(m.ID)))
		i += copy(data[i:], m.ID)
	}
	if m.InboxCount != 0 {
		data[i] = 0x28
		i++
		i = encodeVarintData(data, i, uint64(m.InboxCount))
	}
	if m.IsFriend {
		data[i] = 0x30
		i++
		if m.IsFriend {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.IsGold {
		data[i] = 0x38
		i++
		if m.IsGold {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.LinkKarma != 0 {
		data[i] = 0x40
		i++
		i = encodeVarintData(data, i, uint64(m.LinkKarma))
	}
	if len(m.ModHash) > 0 {
		data[i] = 0x4a
		i++
		i = encodeVarintData(data, i, uint64(len(m.ModHash)))
		i += copy(data[i:], m.ModHash)
	}
	if len(m.Name) > 0 {
		data[i] = 0x52
		i++
		i = encodeVarintData(data, i, uint64(len(m.Name)))
		i += copy(data[i:], m.Name)
	}
	if m.Over18 {
		data[i] = 0x58
		i++
		if m.Over18 {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *GoGoFastCPUInfo) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *GoGoFastCPUInfo) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.CPUs) > 0 {
		for _, msg := range m.CPUs {
			data[i] = 0xa
			i++
			i = encodeVarintData(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *GoGoFastCPU) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *GoGoFastCPU) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Processor != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintData(data, i, uint64(m.Processor))
	}
	if len(m.VendorID) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintData(data, i, uint64(len(m.VendorID)))
		i += copy(data[i:], m.VendorID)
	}
	if len(m.CPUFamily) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintData(data, i, uint64(len(m.CPUFamily)))
		i += copy(data[i:], m.CPUFamily)
	}
	if len(m.Model) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintData(data, i, uint64(len(m.Model)))
		i += copy(data[i:], m.Model)
	}
	if len(m.ModelName) > 0 {
		data[i] = 0x2a
		i++
		i = encodeVarintData(data, i, uint64(len(m.ModelName)))
		i += copy(data[i:], m.ModelName)
	}
	if len(m.Stepping) > 0 {
		data[i] = 0x32
		i++
		i = encodeVarintData(data, i, uint64(len(m.Stepping)))
		i += copy(data[i:], m.Stepping)
	}
	if len(m.Microcode) > 0 {
		data[i] = 0x3a
		i++
		i = encodeVarintData(data, i, uint64(len(m.Microcode)))
		i += copy(data[i:], m.Microcode)
	}
	if m.CPUMHz != 0 {
		data[i] = 0x45
		i++
		i = encodeFixed32Data(data, i, uint32(math.Float32bits(float32(m.CPUMHz))))
	}
	if len(m.CacheSize) > 0 {
		data[i] = 0x4a
		i++
		i = encodeVarintData(data, i, uint64(len(m.CacheSize)))
		i += copy(data[i:], m.CacheSize)
	}
	if m.PhysicalID != 0 {
		data[i] = 0x50
		i++
		i = encodeVarintData(data, i, uint64(m.PhysicalID))
	}
	if m.Siblings != 0 {
		data[i] = 0x58
		i++
		i = encodeVarintData(data, i, uint64(m.Siblings))
	}
	if m.CoreID != 0 {
		data[i] = 0x60
		i++
		i = encodeVarintData(data, i, uint64(m.CoreID))
	}
	if m.CPUCores != 0 {
		data[i] = 0x68
		i++
		i = encodeVarintData(data, i, uint64(m.CPUCores))
	}
	if m.ApicID != 0 {
		data[i] = 0x70
		i++
		i = encodeVarintData(data, i, uint64(m.ApicID))
	}
	if m.InitialApicID != 0 {
		data[i] = 0x78
		i++
		i = encodeVarintData(data, i, uint64(m.InitialApicID))
	}
	if len(m.FPU) > 0 {
		data[i] = 0x82
		i++
		data[i] = 0x1
		i++
		i = encodeVarintData(data, i, uint64(len(m.FPU)))
		i += copy(data[i:], m.FPU)
	}
	if len(m.FPUException) > 0 {
		data[i] = 0x8a
		i++
		data[i] = 0x1
		i++
		i = encodeVarintData(data, i, uint64(len(m.FPUException)))
		i += copy(data[i:], m.FPUException)
	}
	if len(m.CPUIDLevel) > 0 {
		data[i] = 0x92
		i++
		data[i] = 0x1
		i++
		i = encodeVarintData(data, i, uint64(len(m.CPUIDLevel)))
		i += copy(data[i:], m.CPUIDLevel)
	}
	if len(m.WP) > 0 {
		data[i] = 0x9a
		i++
		data[i] = 0x1
		i++
		i = encodeVarintData(data, i, uint64(len(m.WP)))
		i += copy(data[i:], m.WP)
	}
	if len(m.Flags) > 0 {
		data[i] = 0xaa
		i++
		data[i] = 0x1
		i++
		i = encodeVarintData(data, i, uint64(len(m.Flags)))
		i += copy(data[i:], m.Flags)
	}
	if m.BogoMIPS != 0 {
		data[i] = 0xb5
		i++
		data[i] = 0x1
		i++
		i = encodeFixed32Data(data, i, uint32(math.Float32bits(float32(m.BogoMIPS))))
	}
	if len(m.CLFlushSize) > 0 {
		data[i] = 0xba
		i++
		data[i] = 0x1
		i++
		i = encodeVarintData(data, i, uint64(len(m.CLFlushSize)))
		i += copy(data[i:], m.CLFlushSize)
	}
	if len(m.CacheAlignment) > 0 {
		data[i] = 0xc2
		i++
		data[i] = 0x1
		i++
		i = encodeVarintData(data, i, uint64(len(m.CacheAlignment)))
		i += copy(data[i:], m.CacheAlignment)
	}
	if len(m.AddressSizes) > 0 {
		data[i] = 0xca
		i++
		data[i] = 0x1
		i++
		i = encodeVarintData(data, i, uint64(len(m.AddressSizes)))
		i += copy(data[i:], m.AddressSizes)
	}
	if len(m.PowerManagement) > 0 {
		data[i] = 0xd2
		i++
		data[i] = 0x1
		i++
		i = encodeVarintData(data, i, uint64(len(m.PowerManagement)))
		i += copy(data[i:], m.PowerManagement)
	}
	return i, nil
}

func encodeFixed64Data(data []byte, offset int, v uint64) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	data[offset+4] = uint8(v >> 32)
	data[offset+5] = uint8(v >> 40)
	data[offset+6] = uint8(v >> 48)
	data[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Data(data []byte, offset int, v uint32) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintData(data []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		data[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	data[offset] = uint8(v)
	return offset + 1
}
func (m *GoGoFastBasicMemInfo) Size() (n int) {
	var l int
	_ = l
	if m.MemTotal != 0 {
		n += 1 + sovData(uint64(m.MemTotal))
	}
	if m.MemFree != 0 {
		n += 1 + sovData(uint64(m.MemFree))
	}
	if m.MemAvailable != 0 {
		n += 1 + sovData(uint64(m.MemAvailable))
	}
	if m.Buffers != 0 {
		n += 1 + sovData(uint64(m.Buffers))
	}
	if m.Cached != 0 {
		n += 1 + sovData(uint64(m.Cached))
	}
	if m.SwapCached != 0 {
		n += 1 + sovData(uint64(m.SwapCached))
	}
	if m.SwapTotal != 0 {
		n += 1 + sovData(uint64(m.SwapTotal))
	}
	if m.SwapFree != 0 {
		n += 1 + sovData(uint64(m.SwapFree))
	}
	return n
}

func (m *GoGoFastMemInfo) Size() (n int) {
	var l int
	_ = l
	if m.MemTotal != 0 {
		n += 1 + sovData(uint64(m.MemTotal))
	}
	if m.MemFree != 0 {
		n += 1 + sovData(uint64(m.MemFree))
	}
	if m.MemAvailable != 0 {
		n += 1 + sovData(uint64(m.MemAvailable))
	}
	if m.Buffers != 0 {
		n += 1 + sovData(uint64(m.Buffers))
	}
	if m.Cached != 0 {
		n += 1 + sovData(uint64(m.Cached))
	}
	if m.SwapCached != 0 {
		n += 1 + sovData(uint64(m.SwapCached))
	}
	if m.Active != 0 {
		n += 1 + sovData(uint64(m.Active))
	}
	if m.Inactive != 0 {
		n += 1 + sovData(uint64(m.Inactive))
	}
	if m.ActiveAnon != 0 {
		n += 1 + sovData(uint64(m.ActiveAnon))
	}
	if m.InactiveAnon != 0 {
		n += 1 + sovData(uint64(m.InactiveAnon))
	}
	if m.ActiveFile != 0 {
		n += 1 + sovData(uint64(m.ActiveFile))
	}
	if m.InactiveFile != 0 {
		n += 1 + sovData(uint64(m.InactiveFile))
	}
	if m.Unevictable != 0 {
		n += 1 + sovData(uint64(m.Unevictable))
	}
	if m.Mlocked != 0 {
		n += 1 + sovData(uint64(m.Mlocked))
	}
	if m.SwapTotal != 0 {
		n += 1 + sovData(uint64(m.SwapTotal))
	}
	if m.SwapFree != 0 {
		n += 2 + sovData(uint64(m.SwapFree))
	}
	if m.Dirty != 0 {
		n += 2 + sovData(uint64(m.Dirty))
	}
	if m.Writeback != 0 {
		n += 2 + sovData(uint64(m.Writeback))
	}
	if m.AnonPages != 0 {
		n += 2 + sovData(uint64(m.AnonPages))
	}
	if m.Mapped != 0 {
		n += 2 + sovData(uint64(m.Mapped))
	}
	if m.Shmem != 0 {
		n += 2 + sovData(uint64(m.Shmem))
	}
	if m.Slab != 0 {
		n += 2 + sovData(uint64(m.Slab))
	}
	if m.SReclaimable != 0 {
		n += 2 + sovData(uint64(m.SReclaimable))
	}
	if m.SUnreclaim != 0 {
		n += 2 + sovData(uint64(m.SUnreclaim))
	}
	if m.KernelStack != 0 {
		n += 2 + sovData(uint64(m.KernelStack))
	}
	if m.NFSUnstable != 0 {
		n += 2 + sovData(uint64(m.NFSUnstable))
	}
	if m.Bounce != 0 {
		n += 2 + sovData(uint64(m.Bounce))
	}
	if m.WritebackTmp != 0 {
		n += 2 + sovData(uint64(m.WritebackTmp))
	}
	if m.CommitLimit != 0 {
		n += 2 + sovData(uint64(m.CommitLimit))
	}
	if m.VmallocTotal != 0 {
		n += 2 + sovData(uint64(m.VmallocTotal))
	}
	if m.VmallocUsed != 0 {
		n += 2 + sovData(uint64(m.VmallocUsed))
	}
	if m.VmallocChunk != 0 {
		n += 2 + sovData(uint64(m.VmallocChunk))
	}
	if m.HardwareCorrupted != 0 {
		n += 2 + sovData(uint64(m.HardwareCorrupted))
	}
	if m.AnonHugePages != 0 {
		n += 2 + sovData(uint64(m.AnonHugePages))
	}
	if m.HugePagesTotal != 0 {
		n += 2 + sovData(uint64(m.HugePagesTotal))
	}
	if m.HugePagesFree != 0 {
		n += 2 + sovData(uint64(m.HugePagesFree))
	}
	if m.HugePagesRsvd != 0 {
		n += 2 + sovData(uint64(m.HugePagesRsvd))
	}
	if m.Hugepagesize != 0 {
		n += 2 + sovData(uint64(m.Hugepagesize))
	}
	if m.DirectMap4K != 0 {
		n += 2 + sovData(uint64(m.DirectMap4K))
	}
	if m.DirectMap2M != 0 {
		n += 2 + sovData(uint64(m.DirectMap2M))
	}
	return n
}

func (m *GoGoFastMessage) Size() (n int) {
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	if m.DestID != 0 {
		n += 1 + sovData(uint64(m.DestID))
	}
	if m.Type != 0 {
		n += 1 + sovData(uint64(m.Type))
	}
	if m.Kind != 0 {
		n += 1 + sovData(uint64(m.Kind))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	return n
}

func (m *GoGoFastRedditAccount) Size() (n int) {
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	if m.Data != nil {
		l = m.Data.Size()
		n += 1 + l + sovData(uint64(l))
	}
	return n
}

func (m *GoGoFastAccountData) Size() (n int) {
	var l int
	_ = l
	if m.CommentKarma != 0 {
		n += 1 + sovData(uint64(m.CommentKarma))
	}
	if m.HasMail {
		n += 2
	}
	if m.HasModMail {
		n += 2
	}
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	if m.InboxCount != 0 {
		n += 1 + sovData(uint64(m.InboxCount))
	}
	if m.IsFriend {
		n += 2
	}
	if m.IsGold {
		n += 2
	}
	if m.LinkKarma != 0 {
		n += 1 + sovData(uint64(m.LinkKarma))
	}
	l = len(m.ModHash)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	if m.Over18 {
		n += 2
	}
	return n
}

func (m *GoGoFastCPUInfo) Size() (n int) {
	var l int
	_ = l
	if len(m.CPUs) > 0 {
		for _, e := range m.CPUs {
			l = e.Size()
			n += 1 + l + sovData(uint64(l))
		}
	}
	return n
}

func (m *GoGoFastCPU) Size() (n int) {
	var l int
	_ = l
	if m.Processor != 0 {
		n += 1 + sovData(uint64(m.Processor))
	}
	l = len(m.VendorID)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	l = len(m.CPUFamily)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	l = len(m.Model)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	l = len(m.ModelName)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	l = len(m.Stepping)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	l = len(m.Microcode)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	if m.CPUMHz != 0 {
		n += 5
	}
	l = len(m.CacheSize)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	if m.PhysicalID != 0 {
		n += 1 + sovData(uint64(m.PhysicalID))
	}
	if m.Siblings != 0 {
		n += 1 + sovData(uint64(m.Siblings))
	}
	if m.CoreID != 0 {
		n += 1 + sovData(uint64(m.CoreID))
	}
	if m.CPUCores != 0 {
		n += 1 + sovData(uint64(m.CPUCores))
	}
	if m.ApicID != 0 {
		n += 1 + sovData(uint64(m.ApicID))
	}
	if m.InitialApicID != 0 {
		n += 1 + sovData(uint64(m.InitialApicID))
	}
	l = len(m.FPU)
	if l > 0 {
		n += 2 + l + sovData(uint64(l))
	}
	l = len(m.FPUException)
	if l > 0 {
		n += 2 + l + sovData(uint64(l))
	}
	l = len(m.CPUIDLevel)
	if l > 0 {
		n += 2 + l + sovData(uint64(l))
	}
	l = len(m.WP)
	if l > 0 {
		n += 2 + l + sovData(uint64(l))
	}
	l = len(m.Flags)
	if l > 0 {
		n += 2 + l + sovData(uint64(l))
	}
	if m.BogoMIPS != 0 {
		n += 6
	}
	l = len(m.CLFlushSize)
	if l > 0 {
		n += 2 + l + sovData(uint64(l))
	}
	l = len(m.CacheAlignment)
	if l > 0 {
		n += 2 + l + sovData(uint64(l))
	}
	l = len(m.AddressSizes)
	if l > 0 {
		n += 2 + l + sovData(uint64(l))
	}
	l = len(m.PowerManagement)
	if l > 0 {
		n += 2 + l + sovData(uint64(l))
	}
	return n
}

func sovData(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozData(x uint64) (n int) {
	return sovData(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *GoGoFastBasicMemInfo) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GoGoFastBasicMemInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GoGoFastBasicMemInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemTotal", wireType)
			}
			m.MemTotal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.MemTotal |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemFree", wireType)
			}
			m.MemFree = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.MemFree |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemAvailable", wireType)
			}
			m.MemAvailable = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.MemAvailable |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Buffers", wireType)
			}
			m.Buffers = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Buffers |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cached", wireType)
			}
			m.Cached = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Cached |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwapCached", wireType)
			}
			m.SwapCached = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.SwapCached |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwapTotal", wireType)
			}
			m.SwapTotal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.SwapTotal |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwapFree", wireType)
			}
			m.SwapFree = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.SwapFree |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipData(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GoGoFastMemInfo) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GoGoFastMemInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GoGoFastMemInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemTotal", wireType)
			}
			m.MemTotal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.MemTotal |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemFree", wireType)
			}
			m.MemFree = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.MemFree |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemAvailable", wireType)
			}
			m.MemAvailable = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.MemAvailable |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Buffers", wireType)
			}
			m.Buffers = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Buffers |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cached", wireType)
			}
			m.Cached = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Cached |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwapCached", wireType)
			}
			m.SwapCached = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.SwapCached |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Active", wireType)
			}
			m.Active = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Active |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inactive", wireType)
			}
			m.Inactive = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Inactive |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActiveAnon", wireType)
			}
			m.ActiveAnon = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ActiveAnon |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InactiveAnon", wireType)
			}
			m.InactiveAnon = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.InactiveAnon |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActiveFile", wireType)
			}
			m.ActiveFile = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ActiveFile |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InactiveFile", wireType)
			}
			m.InactiveFile = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.InactiveFile |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unevictable", wireType)
			}
			m.Unevictable = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Unevictable |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mlocked", wireType)
			}
			m.Mlocked = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Mlocked |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwapTotal", wireType)
			}
			m.SwapTotal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.SwapTotal |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwapFree", wireType)
			}
			m.SwapFree = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.SwapFree |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dirty", wireType)
			}
			m.Dirty = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Dirty |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Writeback", wireType)
			}
			m.Writeback = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Writeback |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnonPages", wireType)
			}
			m.AnonPages = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.AnonPages |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mapped", wireType)
			}
			m.Mapped = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Mapped |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shmem", wireType)
			}
			m.Shmem = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Shmem |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Slab", wireType)
			}
			m.Slab = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Slab |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SReclaimable", wireType)
			}
			m.SReclaimable = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.SReclaimable |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SUnreclaim", wireType)
			}
			m.SUnreclaim = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.SUnreclaim |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KernelStack", wireType)
			}
			m.KernelStack = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.KernelStack |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NFSUnstable", wireType)
			}
			m.NFSUnstable = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.NFSUnstable |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bounce", wireType)
			}
			m.Bounce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Bounce |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 28:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WritebackTmp", wireType)
			}
			m.WritebackTmp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.WritebackTmp |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 29:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitLimit", wireType)
			}
			m.CommitLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.CommitLimit |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VmallocTotal", wireType)
			}
			m.VmallocTotal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.VmallocTotal |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 31:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VmallocUsed", wireType)
			}
			m.VmallocUsed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.VmallocUsed |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 32:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VmallocChunk", wireType)
			}
			m.VmallocChunk = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.VmallocChunk |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 33:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HardwareCorrupted", wireType)
			}
			m.HardwareCorrupted = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.HardwareCorrupted |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 34:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnonHugePages", wireType)
			}
			m.AnonHugePages = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.AnonHugePages |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 35:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HugePagesTotal", wireType)
			}
			m.HugePagesTotal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.HugePagesTotal |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 36:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HugePagesFree", wireType)
			}
			m.HugePagesFree = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.HugePagesFree |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 37:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HugePagesRsvd", wireType)
			}
			m.HugePagesRsvd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.HugePagesRsvd |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 38:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hugepagesize", wireType)
			}
			m.Hugepagesize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Hugepagesize |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 39:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DirectMap4K", wireType)
			}
			m.DirectMap4K = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.DirectMap4K |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 40:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DirectMap2M", wireType)
			}
			m.DirectMap2M = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.DirectMap2M |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipData(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GoGoFastMessage) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GoGoFastMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GoGoFastMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = append(m.ID[:0], data[iNdEx:postIndex]...)
			if m.ID == nil {
				m.ID = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestID", wireType)
			}
			m.DestID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.DestID |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			m.Kind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Kind |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], data[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GoGoFastRedditAccount) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GoGoFastRedditAccount: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GoGoFastRedditAccount: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data == nil {
				m.Data = &GoGoFastAccountData{}
			}
			if err := m.Data.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GoGoFastAccountData) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GoGoFastAccountData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GoGoFastAccountData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommentKarma", wireType)
			}
			m.CommentKarma = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.CommentKarma |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasMail", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HasMail = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasModMail", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HasModMail = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InboxCount", wireType)
			}
			m.InboxCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.InboxCount |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsFriend", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsFriend = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsGold", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsGold = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LinkKarma", wireType)
			}
			m.LinkKarma = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.LinkKarma |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ModHash = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Over18", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Over18 = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipData(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GoGoFastCPUInfo) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GoGoFastCPUInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GoGoFastCPUInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CPUs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CPUs = append(m.CPUs, &GoGoFastCPU{})
			if err := m.CPUs[len(m.CPUs)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GoGoFastCPU) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GoGoFastCPU: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GoGoFastCPU: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Processor", wireType)
			}
			m.Processor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Processor |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VendorID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VendorID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CPUFamily", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CPUFamily = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Model", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Model = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModelName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ModelName = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stepping", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Stepping = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Microcode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Microcode = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field CPUMHz", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(data[iNdEx-4])
			v |= uint32(data[iNdEx-3]) << 8
			v |= uint32(data[iNdEx-2]) << 16
			v |= uint32(data[iNdEx-1]) << 24
			m.CPUMHz = float32(math.Float32frombits(v))
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CacheSize", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CacheSize = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhysicalID", wireType)
			}
			m.PhysicalID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.PhysicalID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Siblings", wireType)
			}
			m.Siblings = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Siblings |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CoreID", wireType)
			}
			m.CoreID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.CoreID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CPUCores", wireType)
			}
			m.CPUCores = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.CPUCores |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApicID", wireType)
			}
			m.ApicID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ApicID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitialApicID", wireType)
			}
			m.InitialApicID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.InitialApicID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FPU", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FPU = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FPUException", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FPUException = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CPUIDLevel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CPUIDLevel = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WP = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Flags = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 22:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field BogoMIPS", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(data[iNdEx-4])
			v |= uint32(data[iNdEx-3]) << 8
			v |= uint32(data[iNdEx-2]) << 16
			v |= uint32(data[iNdEx-1]) << 24
			m.BogoMIPS = float32(math.Float32frombits(v))
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CLFlushSize", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CLFlushSize = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CacheAlignment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CacheAlignment = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddressSizes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AddressSizes = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PowerManagement", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PowerManagement = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipData(data []byte) (n int, err error) {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowData
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowData
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if data[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowData
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthData
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowData
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipData(data[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthData = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowData   = fmt.Errorf("proto: integer overflow")
)

var fileDescriptorData = []byte{
	// 1328 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xd4, 0x56, 0xcb, 0x72, 0x1b, 0x45,
	0x17, 0xfe, 0x6d, 0x5d, 0xac, 0x69, 0xcb, 0x76, 0x3c, 0x89, 0x93, 0xf9, 0x4d, 0x62, 0x82, 0x08,
	0x21, 0x54, 0x51, 0xa9, 0x4a, 0x60, 0xc1, 0x82, 0x8d, 0x2f, 0x28, 0x56, 0xc5, 0x0a, 0xaa, 0x51,
	0x9c, 0x54, 0xb1, 0x6b, 0xf5, 0xb4, 0x34, 0x5d, 0x9a, 0x5b, 0x4d, 0x8f, 0xe4, 0x38, 0x4b, 0x78,
	0x09, 0xde, 0x85, 0x17, 0x60, 0xc9, 0x23, 0x50, 0xb0, 0xe0, 0x25, 0x58, 0x70, 0xce, 0xe9, 0x9e,
	0xd1, 0xc8, 0x50, 0xec, 0x59, 0x38, 0x99, 0xf3, 0x9d, 0xfb, 0xa5, 0xcf, 0x11, 0x63, 0x01, 0x2f,
	0xf8, 0xd3, 0x2c, 0x4f, 0x8b, 0xd4, 0xed, 0xd0, 0x7f, 0x93, 0xc5, 0xb4, 0xf7, 0xe7, 0x06, 0xbb,
	0xf3, 0x22, 0x7d, 0x91, 0xf6, 0xb9, 0x2e, 0x4e, 0xb8, 0x56, 0x62, 0x28, 0xe3, 0x41, 0x32, 0x4d,
	0xdd, 0x43, 0xd6, 0x81, 0xcf, 0xd7, 0x69, 0xc1, 0x23, 0x6f, 0xe3, 0xe1, 0xc6, 0x93, 0x86, 0xdf,
	0x89, 0x2d, 0xed, 0x7a, 0x6c, 0x0b, 0x78, 0xfd, 0x5c, 0x4a, 0x6f, 0x93, 0x58, 0x5b, 0xb1, 0x21,
	0xdd, 0x1e, 0xeb, 0x02, 0xe7, 0x78, 0xc9, 0x55, 0xc4, 0x27, 0x91, 0xf4, 0x1a, 0xc4, 0xee, 0xc6,
	0x35, 0x0c, 0xb5, 0x4f, 0x16, 0xd3, 0xa9, 0xcc, 0xb5, 0xd7, 0x34, 0xda, 0x13, 0x43, 0xba, 0x77,
	0x59, 0xfb, 0x94, 0x8b, 0x50, 0x06, 0x5e, 0x8b, 0x18, 0x6d, 0x41, 0x94, 0x7b, 0xc4, 0xd8, 0xf8,
	0x8a, 0x67, 0x96, 0xd7, 0x26, 0x1e, 0xd3, 0x15, 0xe2, 0xde, 0x67, 0x0e, 0xf2, 0x4d, 0xb0, 0x5b,
	0xc4, 0x76, 0x74, 0x09, 0x60, 0x26, 0xc8, 0xa5, 0x70, 0x3b, 0x26, 0x13, 0x6d, 0xe9, 0xde, 0x0f,
	0x8c, 0xed, 0x95, 0xe9, 0xff, 0x17, 0x33, 0x07, 0xbd, 0x63, 0x51, 0xa8, 0xa5, 0xb4, 0x69, 0xb7,
	0x39, 0x51, 0x98, 0xc3, 0x20, 0x31, 0xdf, 0x65, 0xce, 0xca, 0xd2, 0x68, 0xd3, 0xe8, 0x1c, 0x27,
	0x69, 0xe2, 0x39, 0xc6, 0x26, 0xaf, 0x10, 0xcc, 0xa4, 0xd4, 0x25, 0x09, 0x66, 0x32, 0x51, 0x35,
	0x6c, 0x65, 0xa3, 0xaf, 0x20, 0xd7, 0xed, 0xba, 0x0d, 0x44, 0xea, 0x36, 0x48, 0xa2, 0xbb, 0x6e,
	0x83, 0x64, 0x1e, 0xb2, 0xed, 0xcb, 0x44, 0x2e, 0x95, 0x28, 0xa8, 0x60, 0x3b, 0x24, 0xb2, 0xbd,
	0x58, 0x41, 0x54, 0xed, 0x28, 0x15, 0x73, 0x48, 0x7d, 0xd7, 0x56, 0xdb, 0x90, 0xeb, 0x1d, 0xdf,
	0xfb, 0xb7, 0x8e, 0xdf, 0x5a, 0xef, 0xb8, 0x7b, 0x87, 0xb5, 0xce, 0x54, 0x5e, 0x5c, 0x7b, 0xfb,
	0xc4, 0x68, 0x05, 0x48, 0xa0, 0xbd, 0xb7, 0xb9, 0x2a, 0xe4, 0x84, 0x8b, 0xb9, 0xe7, 0x1a, 0x7b,
	0x57, 0x25, 0x80, 0x5c, 0xcc, 0x7a, 0xc4, 0x67, 0x52, 0x7b, 0xb7, 0x0d, 0x97, 0x97, 0x00, 0xf6,
	0x60, 0xc8, 0xb3, 0x0c, 0x82, 0xbc, 0x63, 0x7a, 0x10, 0x13, 0x85, 0x9e, 0xc6, 0x21, 0xf4, 0xdf,
	0x3b, 0x30, 0x9e, 0x34, 0x12, 0xae, 0xcb, 0x9a, 0x63, 0x98, 0x06, 0xef, 0x2e, 0x81, 0x4d, 0x0d,
	0xdf, 0x58, 0xad, 0xb1, 0x2f, 0x45, 0xc4, 0x55, 0x4c, 0xa5, 0xb8, 0x67, 0xaa, 0xa5, 0x6b, 0x18,
	0x4d, 0xc2, 0x65, 0x92, 0x1b, 0xc4, 0xf3, 0xec, 0x24, 0x54, 0x08, 0x56, 0xf3, 0xa5, 0xcc, 0x13,
	0x19, 0x8d, 0x0b, 0xcc, 0xe1, 0xff, 0xa6, 0x9a, 0xf3, 0x15, 0x84, 0x12, 0xaf, 0xfa, 0x60, 0x43,
	0x9b, 0x7a, 0x1f, 0x1a, 0x89, 0x64, 0x05, 0x61, 0x26, 0x27, 0xe9, 0x22, 0x11, 0xd2, 0xfb, 0xc0,
	0x64, 0x32, 0x21, 0x0a, 0xe3, 0xab, 0xaa, 0xf3, 0x3a, 0xce, 0xbc, 0xfb, 0x26, 0xbe, 0xab, 0x1a,
	0x86, 0xd6, 0x4f, 0xd3, 0x38, 0x56, 0xc5, 0x85, 0x82, 0x7f, 0xbc, 0x07, 0xc6, 0xba, 0x58, 0x41,
	0x68, 0xe5, 0x4d, 0xcc, 0x23, 0xe8, 0xa0, 0x69, 0xdb, 0x91, 0xb1, 0xb2, 0xac, 0x61, 0x68, 0xc5,
	0xca, 0x5c, 0x6a, 0x28, 0xe8, 0x87, 0xc6, 0xca, 0x72, 0x05, 0xd5, 0xac, 0x9c, 0x86, 0x8b, 0x64,
	0xee, 0x3d, 0x5c, 0xb3, 0x42, 0x98, 0xfb, 0x39, 0xdb, 0x3f, 0xe7, 0x79, 0x70, 0xc5, 0x73, 0x79,
	0x9a, 0xe6, 0xf9, 0x22, 0x2b, 0xc0, 0xd6, 0x47, 0x24, 0xb8, 0x1f, 0xde, 0x64, 0xb8, 0x8f, 0xd8,
	0x0e, 0x76, 0xf7, 0x7c, 0x31, 0x93, 0xa6, 0xc3, 0x3d, 0x92, 0xdc, 0xe1, 0x75, 0xd0, 0x7d, 0xcc,
	0x76, 0x2b, 0xc2, 0xc4, 0xff, 0x31, 0x89, 0xed, 0x86, 0x6b, 0x28, 0x5a, 0xab, 0xe4, 0x68, 0x00,
	0x1f, 0x19, 0x6b, 0x61, 0x1d, 0x5c, 0x93, 0xf2, 0xf5, 0x32, 0xf0, 0x3e, 0xb9, 0x21, 0x85, 0x20,
	0xe6, 0x8a, 0x52, 0x19, 0x02, 0xea, 0xbd, 0xf4, 0x1e, 0x9b, 0x5c, 0xc3, 0x1a, 0x86, 0x15, 0x83,
	0x79, 0x96, 0xa2, 0x80, 0x19, 0xfc, 0x72, 0xee, 0x7d, 0x6a, 0x2a, 0x16, 0xac, 0xa0, 0x35, 0x89,
	0xe7, 0x43, 0xef, 0xc9, 0x0d, 0x89, 0xe7, 0xc3, 0xde, 0xa2, 0xbe, 0x04, 0xb5, 0x06, 0xd3, 0xee,
	0x2e, 0xdb, 0x1c, 0x9c, 0xd1, 0xfa, 0xeb, 0xfa, 0x9b, 0xea, 0x0c, 0x47, 0xe3, 0x4c, 0xea, 0x02,
	0x30, 0xdc, 0x7b, 0x3b, 0x7e, 0x3b, 0x20, 0x0a, 0xc7, 0xf9, 0xf5, 0x75, 0x66, 0xd6, 0x5d, 0xcb,
	0x6f, 0x16, 0xf0, 0x8d, 0xd8, 0x4b, 0x95, 0x04, 0xb4, 0xe3, 0x00, 0x9b, 0xc3, 0x37, 0x62, 0x67,
	0x70, 0x7f, 0x68, 0xbd, 0x75, 0xfd, 0x26, 0xde, 0xa2, 0xde, 0xf7, 0x1b, 0xec, 0xa0, 0xf4, 0xeb,
	0xcb, 0x20, 0x50, 0xc5, 0xb1, 0x10, 0x30, 0x71, 0x45, 0xcd, 0xbb, 0x43, 0xde, 0x41, 0xfb, 0x15,
	0x8f, 0xcd, 0xce, 0x75, 0xfc, 0x66, 0x02, 0xdf, 0x95, 0x97, 0x86, 0xc1, 0xc8, 0xcb, 0x33, 0xeb,
	0x05, 0x3d, 0x6f, 0x3f, 0x7f, 0xf0, 0xb4, 0x3c, 0x73, 0x4f, 0x4b, 0x37, 0xd6, 0x01, 0x0a, 0xd9,
	0x20, 0x7e, 0xda, 0x64, 0xb7, 0xff, 0x81, 0x8b, 0xb5, 0xc7, 0x79, 0x96, 0x49, 0xf1, 0x92, 0xe7,
	0x31, 0xb7, 0x97, 0xa0, 0x2b, 0x6a, 0x18, 0xee, 0xa7, 0x73, 0xae, 0x87, 0xb0, 0xde, 0x29, 0xb2,
	0x8e, 0xbf, 0x15, 0x1a, 0x12, 0x5f, 0x2b, 0x72, 0xd2, 0x80, 0x98, 0x0d, 0x62, 0xb2, 0xb0, 0x42,
	0x6c, 0x82, 0xcd, 0x2a, 0x41, 0x90, 0x1f, 0x24, 0x93, 0xf4, 0xdd, 0x29, 0xfa, 0xb7, 0x37, 0x80,
	0xa9, 0x0a, 0xa1, 0x7d, 0x0e, 0x93, 0xa3, 0x64, 0x62, 0xae, 0x40, 0x07, 0xf6, 0xb9, 0xa5, 0xb1,
	0x35, 0x03, 0xfd, 0x22, 0x8d, 0x02, 0xba, 0x01, 0x1d, 0xbf, 0xad, 0x88, 0xc2, 0xad, 0x75, 0xa1,
	0x92, 0xb9, 0x09, 0xdf, 0x1c, 0x01, 0x27, 0x2a, 0x01, 0xda, 0xad, 0x69, 0x00, 0x41, 0x86, 0x74,
	0x02, 0x1c, 0xd8, 0xad, 0x86, 0xac, 0x8a, 0xcd, 0x6a, 0xc5, 0x06, 0x1f, 0xdf, 0x2e, 0x65, 0xfe,
	0xec, 0x2b, 0xda, 0xf5, 0xe0, 0x23, 0x25, 0xaa, 0xf7, 0xf5, 0x6a, 0x72, 0x4e, 0x47, 0x97, 0x74,
	0x3e, 0x3f, 0x63, 0x4d, 0xf8, 0xd4, 0x50, 0xb0, 0x06, 0xf4, 0xe0, 0xe0, 0xef, 0x3d, 0x00, 0xae,
	0xdf, 0x14, 0x20, 0xd2, 0xfb, 0xa3, 0xc5, 0xb6, 0x6b, 0x28, 0x46, 0x3c, 0xca, 0x53, 0x01, 0x23,
	0x98, 0xe6, 0x54, 0xf0, 0x96, 0xef, 0x64, 0x25, 0x80, 0x35, 0x78, 0x03, 0xf9, 0xa6, 0xb9, 0x1d,
	0x42, 0xc7, 0xef, 0x2c, 0x2d, 0x8d, 0x9a, 0x60, 0xa0, 0xcf, 0x63, 0x15, 0x5d, 0xdb, 0x89, 0x70,
	0x44, 0x09, 0xe0, 0x26, 0x86, 0x5c, 0x65, 0x64, 0x0b, 0xde, 0x8a, 0x91, 0x40, 0x1d, 0x42, 0x29,
	0xd9, 0x96, 0xd1, 0x89, 0x4b, 0x80, 0x6e, 0x48, 0x21, 0xb3, 0x4c, 0x25, 0x33, 0xaa, 0x38, 0x78,
	0xd3, 0x96, 0x26, 0x4d, 0x25, 0x20, 0x30, 0x90, 0xa6, 0xa2, 0xa3, 0x66, 0x09, 0xd0, 0x2d, 0x1f,
	0x5d, 0x0e, 0xcf, 0xdf, 0x53, 0xd1, 0x37, 0xe1, 0x96, 0x13, 0x45, 0x31, 0xe2, 0xd5, 0x1e, 0xe3,
	0x53, 0x76, 0x6c, 0x8c, 0x25, 0x80, 0x13, 0x30, 0x0a, 0xaf, 0xe1, 0x07, 0x18, 0x8f, 0x20, 0x3f,
	0x46, 0xc9, 0xb3, 0xac, 0x42, 0x28, 0x1e, 0x35, 0x81, 0xfe, 0xcd, 0x34, 0xf5, 0xa0, 0x05, 0xf1,
	0x58, 0x9a, 0x3c, 0xa6, 0xb9, 0x04, 0xbd, 0x2e, 0x71, 0xda, 0x82, 0x28, 0xd4, 0x81, 0x48, 0x90,
	0xa5, 0xe9, 0xbc, 0x82, 0x8e, 0xb0, 0x34, 0xfd, 0x72, 0xc8, 0x94, 0x00, 0x9d, 0x5d, 0xa3, 0xc3,
	0x89, 0xc2, 0xcd, 0x34, 0x48, 0x54, 0xa1, 0x78, 0x64, 0xd9, 0x7b, 0xc4, 0xde, 0x51, 0x75, 0xd0,
	0xbd, 0xc5, 0x1a, 0xfd, 0xd1, 0x25, 0x1d, 0x57, 0xc7, 0x6f, 0x4c, 0xa1, 0x77, 0xf0, 0x5e, 0x00,
	0xf9, 0xe6, 0x9d, 0x90, 0x59, 0xa1, 0xe0, 0x57, 0xc3, 0x3e, 0xb1, 0xba, 0xd3, 0x1a, 0x86, 0x39,
	0xe2, 0x94, 0x9c, 0x5d, 0xc8, 0x25, 0x34, 0xc3, 0x25, 0x09, 0x26, 0x2a, 0x04, 0x5f, 0xc5, 0xdb,
	0x11, 0x1d, 0x58, 0x78, 0x15, 0x57, 0x23, 0xec, 0x5b, 0x3f, 0xe2, 0x90, 0xf0, 0x81, 0xe9, 0xdb,
	0x14, 0x09, 0xcc, 0xea, 0x24, 0x9d, 0xa5, 0xc3, 0xc1, 0x68, 0x4c, 0x57, 0x74, 0xd3, 0xef, 0x4c,
	0x2c, 0x4d, 0x57, 0xe8, 0xa2, 0x1f, 0x2d, 0x74, 0x48, 0x55, 0xbe, 0x47, 0x7a, 0xdb, 0x62, 0x05,
	0xe1, 0x1e, 0xa7, 0x2e, 0x1c, 0x47, 0x6a, 0x96, 0xe0, 0x53, 0xa6, 0x5b, 0xea, 0xf8, 0xbb, 0x62,
	0x0d, 0xc5, 0x7c, 0x8e, 0x83, 0x00, 0x2a, 0xa5, 0x51, 0x4d, 0xd3, 0x41, 0x85, 0x7c, 0x78, 0x0d,
	0x73, 0x9f, 0xb0, 0xbd, 0x51, 0x7a, 0x25, 0xf3, 0x21, 0x4f, 0x60, 0x67, 0x92, 0xb1, 0x43, 0x12,
	0xdb, 0xcb, 0xd6, 0xe1, 0x93, 0xc3, 0x9f, 0x7f, 0x3b, 0xda, 0xf8, 0x05, 0xfe, 0x7e, 0x85, 0xbf,
	0x1f, 0x7f, 0x3f, 0xfa, 0xdf, 0x77, 0x9d, 0x19, 0xc4, 0x3c, 0x85, 0xc1, 0x9f, 0xb4, 0xe9, 0x85,
	0x7c, 0xf1, 0x57, 0x00, 0x00, 0x00, 0xff, 0xff, 0x1b, 0x6c, 0x2a, 0x84, 0xa1, 0x0b, 0x00, 0x00,
}
