// DO NOT EDIT!
// Code generated by ffjson <https://github.com/pquerna/ffjson>
// source: info.go
// DO NOT EDIT!

package ffjson

import (
	"bytes"
	"fmt"
	fflib "github.com/pquerna/ffjson/fflib/v1"
)

func (mj *BasicMemInfo) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *BasicMemInfo) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"mem_total":`)
	fflib.FormatBits2(buf, uint64(mj.MemTotal), 10, mj.MemTotal < 0)
	buf.WriteString(`,"mem_free":`)
	fflib.FormatBits2(buf, uint64(mj.MemFree), 10, mj.MemFree < 0)
	buf.WriteString(`,"mem_available":`)
	fflib.FormatBits2(buf, uint64(mj.MemAvailable), 10, mj.MemAvailable < 0)
	buf.WriteString(`,"buffers":`)
	fflib.FormatBits2(buf, uint64(mj.Buffers), 10, mj.Buffers < 0)
	buf.WriteString(`,"cached":`)
	fflib.FormatBits2(buf, uint64(mj.Cached), 10, mj.Cached < 0)
	buf.WriteString(`,"swap_cached":`)
	fflib.FormatBits2(buf, uint64(mj.SwapCached), 10, mj.SwapCached < 0)
	buf.WriteString(`,"swap_total":`)
	fflib.FormatBits2(buf, uint64(mj.SwapTotal), 10, mj.SwapTotal < 0)
	buf.WriteString(`,"swap_free":`)
	fflib.FormatBits2(buf, uint64(mj.SwapFree), 10, mj.SwapFree < 0)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_BasicMemInfobase = iota
	ffj_t_BasicMemInfono_such_key

	ffj_t_BasicMemInfo_MemTotal

	ffj_t_BasicMemInfo_MemFree

	ffj_t_BasicMemInfo_MemAvailable

	ffj_t_BasicMemInfo_Buffers

	ffj_t_BasicMemInfo_Cached

	ffj_t_BasicMemInfo_SwapCached

	ffj_t_BasicMemInfo_SwapTotal

	ffj_t_BasicMemInfo_SwapFree
)

var ffj_key_BasicMemInfo_MemTotal = []byte("mem_total")

var ffj_key_BasicMemInfo_MemFree = []byte("mem_free")

var ffj_key_BasicMemInfo_MemAvailable = []byte("mem_available")

var ffj_key_BasicMemInfo_Buffers = []byte("buffers")

var ffj_key_BasicMemInfo_Cached = []byte("cached")

var ffj_key_BasicMemInfo_SwapCached = []byte("swap_cached")

var ffj_key_BasicMemInfo_SwapTotal = []byte("swap_total")

var ffj_key_BasicMemInfo_SwapFree = []byte("swap_free")

func (uj *BasicMemInfo) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *BasicMemInfo) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_BasicMemInfobase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_BasicMemInfono_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'b':

					if bytes.Equal(ffj_key_BasicMemInfo_Buffers, kn) {
						currentKey = ffj_t_BasicMemInfo_Buffers
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffj_key_BasicMemInfo_Cached, kn) {
						currentKey = ffj_t_BasicMemInfo_Cached
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffj_key_BasicMemInfo_MemTotal, kn) {
						currentKey = ffj_t_BasicMemInfo_MemTotal
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_BasicMemInfo_MemFree, kn) {
						currentKey = ffj_t_BasicMemInfo_MemFree
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_BasicMemInfo_MemAvailable, kn) {
						currentKey = ffj_t_BasicMemInfo_MemAvailable
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffj_key_BasicMemInfo_SwapCached, kn) {
						currentKey = ffj_t_BasicMemInfo_SwapCached
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_BasicMemInfo_SwapTotal, kn) {
						currentKey = ffj_t_BasicMemInfo_SwapTotal
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_BasicMemInfo_SwapFree, kn) {
						currentKey = ffj_t_BasicMemInfo_SwapFree
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_BasicMemInfo_SwapFree, kn) {
					currentKey = ffj_t_BasicMemInfo_SwapFree
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_BasicMemInfo_SwapTotal, kn) {
					currentKey = ffj_t_BasicMemInfo_SwapTotal
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_BasicMemInfo_SwapCached, kn) {
					currentKey = ffj_t_BasicMemInfo_SwapCached
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_BasicMemInfo_Cached, kn) {
					currentKey = ffj_t_BasicMemInfo_Cached
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_BasicMemInfo_Buffers, kn) {
					currentKey = ffj_t_BasicMemInfo_Buffers
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_BasicMemInfo_MemAvailable, kn) {
					currentKey = ffj_t_BasicMemInfo_MemAvailable
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_BasicMemInfo_MemFree, kn) {
					currentKey = ffj_t_BasicMemInfo_MemFree
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_BasicMemInfo_MemTotal, kn) {
					currentKey = ffj_t_BasicMemInfo_MemTotal
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_BasicMemInfono_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_BasicMemInfo_MemTotal:
					goto handle_MemTotal

				case ffj_t_BasicMemInfo_MemFree:
					goto handle_MemFree

				case ffj_t_BasicMemInfo_MemAvailable:
					goto handle_MemAvailable

				case ffj_t_BasicMemInfo_Buffers:
					goto handle_Buffers

				case ffj_t_BasicMemInfo_Cached:
					goto handle_Cached

				case ffj_t_BasicMemInfo_SwapCached:
					goto handle_SwapCached

				case ffj_t_BasicMemInfo_SwapTotal:
					goto handle_SwapTotal

				case ffj_t_BasicMemInfo_SwapFree:
					goto handle_SwapFree

				case ffj_t_BasicMemInfono_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_MemTotal:

	/* handler: uj.MemTotal type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.MemTotal = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MemFree:

	/* handler: uj.MemFree type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.MemFree = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MemAvailable:

	/* handler: uj.MemAvailable type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.MemAvailable = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Buffers:

	/* handler: uj.Buffers type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Buffers = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Cached:

	/* handler: uj.Cached type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Cached = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_SwapCached:

	/* handler: uj.SwapCached type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.SwapCached = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_SwapTotal:

	/* handler: uj.SwapTotal type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.SwapTotal = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_SwapFree:

	/* handler: uj.SwapFree type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.SwapFree = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *MemInfo) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *MemInfo) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"mem_total":`)
	fflib.FormatBits2(buf, uint64(mj.MemTotal), 10, mj.MemTotal < 0)
	buf.WriteString(`,"mem_free":`)
	fflib.FormatBits2(buf, uint64(mj.MemFree), 10, mj.MemFree < 0)
	buf.WriteString(`,"mem_available":`)
	fflib.FormatBits2(buf, uint64(mj.MemAvailable), 10, mj.MemAvailable < 0)
	buf.WriteString(`,"buffers":`)
	fflib.FormatBits2(buf, uint64(mj.Buffers), 10, mj.Buffers < 0)
	buf.WriteString(`,"cached":`)
	fflib.FormatBits2(buf, uint64(mj.Cached), 10, mj.Cached < 0)
	buf.WriteString(`,"swap_cached":`)
	fflib.FormatBits2(buf, uint64(mj.SwapCached), 10, mj.SwapCached < 0)
	buf.WriteString(`,"active":`)
	fflib.FormatBits2(buf, uint64(mj.Active), 10, mj.Active < 0)
	buf.WriteString(`,"inactive":`)
	fflib.FormatBits2(buf, uint64(mj.Inactive), 10, mj.Inactive < 0)
	buf.WriteString(`,"active_anon":`)
	fflib.FormatBits2(buf, uint64(mj.ActiveAnon), 10, mj.ActiveAnon < 0)
	buf.WriteString(`,"inactive_anon":`)
	fflib.FormatBits2(buf, uint64(mj.InactiveAnon), 10, mj.InactiveAnon < 0)
	buf.WriteString(`,"active_file":`)
	fflib.FormatBits2(buf, uint64(mj.ActiveFile), 10, mj.ActiveFile < 0)
	buf.WriteString(`,"inactive_file":`)
	fflib.FormatBits2(buf, uint64(mj.InactiveFile), 10, mj.InactiveFile < 0)
	buf.WriteString(`,"unevictable":`)
	fflib.FormatBits2(buf, uint64(mj.Unevictable), 10, mj.Unevictable < 0)
	buf.WriteString(`,"mlocked":`)
	fflib.FormatBits2(buf, uint64(mj.Mlocked), 10, mj.Mlocked < 0)
	buf.WriteString(`,"swap_total":`)
	fflib.FormatBits2(buf, uint64(mj.SwapTotal), 10, mj.SwapTotal < 0)
	buf.WriteString(`,"swap_free":`)
	fflib.FormatBits2(buf, uint64(mj.SwapFree), 10, mj.SwapFree < 0)
	buf.WriteString(`,"dirty":`)
	fflib.FormatBits2(buf, uint64(mj.Dirty), 10, mj.Dirty < 0)
	buf.WriteString(`,"writeback":`)
	fflib.FormatBits2(buf, uint64(mj.Writeback), 10, mj.Writeback < 0)
	buf.WriteString(`,"anon_pages":`)
	fflib.FormatBits2(buf, uint64(mj.AnonPages), 10, mj.AnonPages < 0)
	buf.WriteString(`,"mapped":`)
	fflib.FormatBits2(buf, uint64(mj.Mapped), 10, mj.Mapped < 0)
	buf.WriteString(`,"sh_mem":`)
	fflib.FormatBits2(buf, uint64(mj.Shmem), 10, mj.Shmem < 0)
	buf.WriteString(`,"slab":`)
	fflib.FormatBits2(buf, uint64(mj.Slab), 10, mj.Slab < 0)
	buf.WriteString(`,"s_reclaimable":`)
	fflib.FormatBits2(buf, uint64(mj.SReclaimable), 10, mj.SReclaimable < 0)
	buf.WriteString(`,"s_unreclaim":`)
	fflib.FormatBits2(buf, uint64(mj.SUnreclaim), 10, mj.SUnreclaim < 0)
	buf.WriteString(`,"kernel_stack":`)
	fflib.FormatBits2(buf, uint64(mj.KernelStack), 10, mj.KernelStack < 0)
	buf.WriteString(`,"nfs_unstable":`)
	fflib.FormatBits2(buf, uint64(mj.NFSUnstable), 10, mj.NFSUnstable < 0)
	buf.WriteString(`,"bounce":`)
	fflib.FormatBits2(buf, uint64(mj.Bounce), 10, mj.Bounce < 0)
	buf.WriteString(`,"writeback_tmp":`)
	fflib.FormatBits2(buf, uint64(mj.WritebackTmp), 10, mj.WritebackTmp < 0)
	buf.WriteString(`,"commit_limit":`)
	fflib.FormatBits2(buf, uint64(mj.CommitLimit), 10, mj.CommitLimit < 0)
	buf.WriteString(`,"vmalloc_total":`)
	fflib.FormatBits2(buf, uint64(mj.VmallocTotal), 10, mj.VmallocTotal < 0)
	buf.WriteString(`,"vmalloc_used":`)
	fflib.FormatBits2(buf, uint64(mj.VmallocUsed), 10, mj.VmallocUsed < 0)
	buf.WriteString(`,"vmalloc_chunked":`)
	fflib.FormatBits2(buf, uint64(mj.VmallocChunk), 10, mj.VmallocChunk < 0)
	buf.WriteString(`,"hardware_corrupted":`)
	fflib.FormatBits2(buf, uint64(mj.HardwareCorrupted), 10, mj.HardwareCorrupted < 0)
	buf.WriteString(`,"anon_huge_pages":`)
	fflib.FormatBits2(buf, uint64(mj.AnonHugePages), 10, mj.AnonHugePages < 0)
	buf.WriteString(`,"huge_pages_total":`)
	fflib.FormatBits2(buf, uint64(mj.HugePagesTotal), 10, mj.HugePagesTotal < 0)
	buf.WriteString(`,"huge_pages_free":`)
	fflib.FormatBits2(buf, uint64(mj.HugePagesFree), 10, mj.HugePagesFree < 0)
	buf.WriteString(`,"huge_pages_rsvd":`)
	fflib.FormatBits2(buf, uint64(mj.HugePagesRsvd), 10, mj.HugePagesRsvd < 0)
	buf.WriteString(`,"huge_pages_size":`)
	fflib.FormatBits2(buf, uint64(mj.Hugepagesize), 10, mj.Hugepagesize < 0)
	buf.WriteString(`,"direct_map_4k":`)
	fflib.FormatBits2(buf, uint64(mj.DirectMap4k), 10, mj.DirectMap4k < 0)
	buf.WriteString(`,"direct_map_2m":`)
	fflib.FormatBits2(buf, uint64(mj.DirectMap2M), 10, mj.DirectMap2M < 0)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_MemInfobase = iota
	ffj_t_MemInfono_such_key

	ffj_t_MemInfo_MemTotal

	ffj_t_MemInfo_MemFree

	ffj_t_MemInfo_MemAvailable

	ffj_t_MemInfo_Buffers

	ffj_t_MemInfo_Cached

	ffj_t_MemInfo_SwapCached

	ffj_t_MemInfo_Active

	ffj_t_MemInfo_Inactive

	ffj_t_MemInfo_ActiveAnon

	ffj_t_MemInfo_InactiveAnon

	ffj_t_MemInfo_ActiveFile

	ffj_t_MemInfo_InactiveFile

	ffj_t_MemInfo_Unevictable

	ffj_t_MemInfo_Mlocked

	ffj_t_MemInfo_SwapTotal

	ffj_t_MemInfo_SwapFree

	ffj_t_MemInfo_Dirty

	ffj_t_MemInfo_Writeback

	ffj_t_MemInfo_AnonPages

	ffj_t_MemInfo_Mapped

	ffj_t_MemInfo_Shmem

	ffj_t_MemInfo_Slab

	ffj_t_MemInfo_SReclaimable

	ffj_t_MemInfo_SUnreclaim

	ffj_t_MemInfo_KernelStack

	ffj_t_MemInfo_NFSUnstable

	ffj_t_MemInfo_Bounce

	ffj_t_MemInfo_WritebackTmp

	ffj_t_MemInfo_CommitLimit

	ffj_t_MemInfo_VmallocTotal

	ffj_t_MemInfo_VmallocUsed

	ffj_t_MemInfo_VmallocChunk

	ffj_t_MemInfo_HardwareCorrupted

	ffj_t_MemInfo_AnonHugePages

	ffj_t_MemInfo_HugePagesTotal

	ffj_t_MemInfo_HugePagesFree

	ffj_t_MemInfo_HugePagesRsvd

	ffj_t_MemInfo_Hugepagesize

	ffj_t_MemInfo_DirectMap4k

	ffj_t_MemInfo_DirectMap2M
)

var ffj_key_MemInfo_MemTotal = []byte("mem_total")

var ffj_key_MemInfo_MemFree = []byte("mem_free")

var ffj_key_MemInfo_MemAvailable = []byte("mem_available")

var ffj_key_MemInfo_Buffers = []byte("buffers")

var ffj_key_MemInfo_Cached = []byte("cached")

var ffj_key_MemInfo_SwapCached = []byte("swap_cached")

var ffj_key_MemInfo_Active = []byte("active")

var ffj_key_MemInfo_Inactive = []byte("inactive")

var ffj_key_MemInfo_ActiveAnon = []byte("active_anon")

var ffj_key_MemInfo_InactiveAnon = []byte("inactive_anon")

var ffj_key_MemInfo_ActiveFile = []byte("active_file")

var ffj_key_MemInfo_InactiveFile = []byte("inactive_file")

var ffj_key_MemInfo_Unevictable = []byte("unevictable")

var ffj_key_MemInfo_Mlocked = []byte("mlocked")

var ffj_key_MemInfo_SwapTotal = []byte("swap_total")

var ffj_key_MemInfo_SwapFree = []byte("swap_free")

var ffj_key_MemInfo_Dirty = []byte("dirty")

var ffj_key_MemInfo_Writeback = []byte("writeback")

var ffj_key_MemInfo_AnonPages = []byte("anon_pages")

var ffj_key_MemInfo_Mapped = []byte("mapped")

var ffj_key_MemInfo_Shmem = []byte("sh_mem")

var ffj_key_MemInfo_Slab = []byte("slab")

var ffj_key_MemInfo_SReclaimable = []byte("s_reclaimable")

var ffj_key_MemInfo_SUnreclaim = []byte("s_unreclaim")

var ffj_key_MemInfo_KernelStack = []byte("kernel_stack")

var ffj_key_MemInfo_NFSUnstable = []byte("nfs_unstable")

var ffj_key_MemInfo_Bounce = []byte("bounce")

var ffj_key_MemInfo_WritebackTmp = []byte("writeback_tmp")

var ffj_key_MemInfo_CommitLimit = []byte("commit_limit")

var ffj_key_MemInfo_VmallocTotal = []byte("vmalloc_total")

var ffj_key_MemInfo_VmallocUsed = []byte("vmalloc_used")

var ffj_key_MemInfo_VmallocChunk = []byte("vmalloc_chunked")

var ffj_key_MemInfo_HardwareCorrupted = []byte("hardware_corrupted")

var ffj_key_MemInfo_AnonHugePages = []byte("anon_huge_pages")

var ffj_key_MemInfo_HugePagesTotal = []byte("huge_pages_total")

var ffj_key_MemInfo_HugePagesFree = []byte("huge_pages_free")

var ffj_key_MemInfo_HugePagesRsvd = []byte("huge_pages_rsvd")

var ffj_key_MemInfo_Hugepagesize = []byte("huge_pages_size")

var ffj_key_MemInfo_DirectMap4k = []byte("direct_map_4k")

var ffj_key_MemInfo_DirectMap2M = []byte("direct_map_2m")

func (uj *MemInfo) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *MemInfo) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_MemInfobase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_MemInfono_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffj_key_MemInfo_Active, kn) {
						currentKey = ffj_t_MemInfo_Active
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_MemInfo_ActiveAnon, kn) {
						currentKey = ffj_t_MemInfo_ActiveAnon
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_MemInfo_ActiveFile, kn) {
						currentKey = ffj_t_MemInfo_ActiveFile
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_MemInfo_AnonPages, kn) {
						currentKey = ffj_t_MemInfo_AnonPages
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_MemInfo_AnonHugePages, kn) {
						currentKey = ffj_t_MemInfo_AnonHugePages
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'b':

					if bytes.Equal(ffj_key_MemInfo_Buffers, kn) {
						currentKey = ffj_t_MemInfo_Buffers
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_MemInfo_Bounce, kn) {
						currentKey = ffj_t_MemInfo_Bounce
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffj_key_MemInfo_Cached, kn) {
						currentKey = ffj_t_MemInfo_Cached
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_MemInfo_CommitLimit, kn) {
						currentKey = ffj_t_MemInfo_CommitLimit
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffj_key_MemInfo_Dirty, kn) {
						currentKey = ffj_t_MemInfo_Dirty
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_MemInfo_DirectMap4k, kn) {
						currentKey = ffj_t_MemInfo_DirectMap4k
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_MemInfo_DirectMap2M, kn) {
						currentKey = ffj_t_MemInfo_DirectMap2M
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'h':

					if bytes.Equal(ffj_key_MemInfo_HardwareCorrupted, kn) {
						currentKey = ffj_t_MemInfo_HardwareCorrupted
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_MemInfo_HugePagesTotal, kn) {
						currentKey = ffj_t_MemInfo_HugePagesTotal
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_MemInfo_HugePagesFree, kn) {
						currentKey = ffj_t_MemInfo_HugePagesFree
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_MemInfo_HugePagesRsvd, kn) {
						currentKey = ffj_t_MemInfo_HugePagesRsvd
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_MemInfo_Hugepagesize, kn) {
						currentKey = ffj_t_MemInfo_Hugepagesize
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffj_key_MemInfo_Inactive, kn) {
						currentKey = ffj_t_MemInfo_Inactive
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_MemInfo_InactiveAnon, kn) {
						currentKey = ffj_t_MemInfo_InactiveAnon
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_MemInfo_InactiveFile, kn) {
						currentKey = ffj_t_MemInfo_InactiveFile
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'k':

					if bytes.Equal(ffj_key_MemInfo_KernelStack, kn) {
						currentKey = ffj_t_MemInfo_KernelStack
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffj_key_MemInfo_MemTotal, kn) {
						currentKey = ffj_t_MemInfo_MemTotal
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_MemInfo_MemFree, kn) {
						currentKey = ffj_t_MemInfo_MemFree
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_MemInfo_MemAvailable, kn) {
						currentKey = ffj_t_MemInfo_MemAvailable
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_MemInfo_Mlocked, kn) {
						currentKey = ffj_t_MemInfo_Mlocked
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_MemInfo_Mapped, kn) {
						currentKey = ffj_t_MemInfo_Mapped
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'n':

					if bytes.Equal(ffj_key_MemInfo_NFSUnstable, kn) {
						currentKey = ffj_t_MemInfo_NFSUnstable
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffj_key_MemInfo_SwapCached, kn) {
						currentKey = ffj_t_MemInfo_SwapCached
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_MemInfo_SwapTotal, kn) {
						currentKey = ffj_t_MemInfo_SwapTotal
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_MemInfo_SwapFree, kn) {
						currentKey = ffj_t_MemInfo_SwapFree
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_MemInfo_Shmem, kn) {
						currentKey = ffj_t_MemInfo_Shmem
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_MemInfo_Slab, kn) {
						currentKey = ffj_t_MemInfo_Slab
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_MemInfo_SReclaimable, kn) {
						currentKey = ffj_t_MemInfo_SReclaimable
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_MemInfo_SUnreclaim, kn) {
						currentKey = ffj_t_MemInfo_SUnreclaim
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffj_key_MemInfo_Unevictable, kn) {
						currentKey = ffj_t_MemInfo_Unevictable
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'v':

					if bytes.Equal(ffj_key_MemInfo_VmallocTotal, kn) {
						currentKey = ffj_t_MemInfo_VmallocTotal
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_MemInfo_VmallocUsed, kn) {
						currentKey = ffj_t_MemInfo_VmallocUsed
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_MemInfo_VmallocChunk, kn) {
						currentKey = ffj_t_MemInfo_VmallocChunk
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'w':

					if bytes.Equal(ffj_key_MemInfo_Writeback, kn) {
						currentKey = ffj_t_MemInfo_Writeback
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_MemInfo_WritebackTmp, kn) {
						currentKey = ffj_t_MemInfo_WritebackTmp
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.AsciiEqualFold(ffj_key_MemInfo_DirectMap2M, kn) {
					currentKey = ffj_t_MemInfo_DirectMap2M
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_MemInfo_DirectMap4k, kn) {
					currentKey = ffj_t_MemInfo_DirectMap4k
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_MemInfo_Hugepagesize, kn) {
					currentKey = ffj_t_MemInfo_Hugepagesize
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_MemInfo_HugePagesRsvd, kn) {
					currentKey = ffj_t_MemInfo_HugePagesRsvd
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_MemInfo_HugePagesFree, kn) {
					currentKey = ffj_t_MemInfo_HugePagesFree
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_MemInfo_HugePagesTotal, kn) {
					currentKey = ffj_t_MemInfo_HugePagesTotal
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_MemInfo_AnonHugePages, kn) {
					currentKey = ffj_t_MemInfo_AnonHugePages
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_MemInfo_HardwareCorrupted, kn) {
					currentKey = ffj_t_MemInfo_HardwareCorrupted
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_MemInfo_VmallocChunk, kn) {
					currentKey = ffj_t_MemInfo_VmallocChunk
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_MemInfo_VmallocUsed, kn) {
					currentKey = ffj_t_MemInfo_VmallocUsed
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_MemInfo_VmallocTotal, kn) {
					currentKey = ffj_t_MemInfo_VmallocTotal
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_MemInfo_CommitLimit, kn) {
					currentKey = ffj_t_MemInfo_CommitLimit
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_MemInfo_WritebackTmp, kn) {
					currentKey = ffj_t_MemInfo_WritebackTmp
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_MemInfo_Bounce, kn) {
					currentKey = ffj_t_MemInfo_Bounce
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_MemInfo_NFSUnstable, kn) {
					currentKey = ffj_t_MemInfo_NFSUnstable
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_MemInfo_KernelStack, kn) {
					currentKey = ffj_t_MemInfo_KernelStack
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_MemInfo_SUnreclaim, kn) {
					currentKey = ffj_t_MemInfo_SUnreclaim
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_MemInfo_SReclaimable, kn) {
					currentKey = ffj_t_MemInfo_SReclaimable
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_MemInfo_Slab, kn) {
					currentKey = ffj_t_MemInfo_Slab
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_MemInfo_Shmem, kn) {
					currentKey = ffj_t_MemInfo_Shmem
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_MemInfo_Mapped, kn) {
					currentKey = ffj_t_MemInfo_Mapped
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_MemInfo_AnonPages, kn) {
					currentKey = ffj_t_MemInfo_AnonPages
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_MemInfo_Writeback, kn) {
					currentKey = ffj_t_MemInfo_Writeback
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_MemInfo_Dirty, kn) {
					currentKey = ffj_t_MemInfo_Dirty
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_MemInfo_SwapFree, kn) {
					currentKey = ffj_t_MemInfo_SwapFree
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_MemInfo_SwapTotal, kn) {
					currentKey = ffj_t_MemInfo_SwapTotal
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_MemInfo_Mlocked, kn) {
					currentKey = ffj_t_MemInfo_Mlocked
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_MemInfo_Unevictable, kn) {
					currentKey = ffj_t_MemInfo_Unevictable
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_MemInfo_InactiveFile, kn) {
					currentKey = ffj_t_MemInfo_InactiveFile
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_MemInfo_ActiveFile, kn) {
					currentKey = ffj_t_MemInfo_ActiveFile
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_MemInfo_InactiveAnon, kn) {
					currentKey = ffj_t_MemInfo_InactiveAnon
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_MemInfo_ActiveAnon, kn) {
					currentKey = ffj_t_MemInfo_ActiveAnon
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_MemInfo_Inactive, kn) {
					currentKey = ffj_t_MemInfo_Inactive
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_MemInfo_Active, kn) {
					currentKey = ffj_t_MemInfo_Active
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_MemInfo_SwapCached, kn) {
					currentKey = ffj_t_MemInfo_SwapCached
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_MemInfo_Cached, kn) {
					currentKey = ffj_t_MemInfo_Cached
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_MemInfo_Buffers, kn) {
					currentKey = ffj_t_MemInfo_Buffers
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_MemInfo_MemAvailable, kn) {
					currentKey = ffj_t_MemInfo_MemAvailable
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_MemInfo_MemFree, kn) {
					currentKey = ffj_t_MemInfo_MemFree
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_MemInfo_MemTotal, kn) {
					currentKey = ffj_t_MemInfo_MemTotal
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_MemInfono_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_MemInfo_MemTotal:
					goto handle_MemTotal

				case ffj_t_MemInfo_MemFree:
					goto handle_MemFree

				case ffj_t_MemInfo_MemAvailable:
					goto handle_MemAvailable

				case ffj_t_MemInfo_Buffers:
					goto handle_Buffers

				case ffj_t_MemInfo_Cached:
					goto handle_Cached

				case ffj_t_MemInfo_SwapCached:
					goto handle_SwapCached

				case ffj_t_MemInfo_Active:
					goto handle_Active

				case ffj_t_MemInfo_Inactive:
					goto handle_Inactive

				case ffj_t_MemInfo_ActiveAnon:
					goto handle_ActiveAnon

				case ffj_t_MemInfo_InactiveAnon:
					goto handle_InactiveAnon

				case ffj_t_MemInfo_ActiveFile:
					goto handle_ActiveFile

				case ffj_t_MemInfo_InactiveFile:
					goto handle_InactiveFile

				case ffj_t_MemInfo_Unevictable:
					goto handle_Unevictable

				case ffj_t_MemInfo_Mlocked:
					goto handle_Mlocked

				case ffj_t_MemInfo_SwapTotal:
					goto handle_SwapTotal

				case ffj_t_MemInfo_SwapFree:
					goto handle_SwapFree

				case ffj_t_MemInfo_Dirty:
					goto handle_Dirty

				case ffj_t_MemInfo_Writeback:
					goto handle_Writeback

				case ffj_t_MemInfo_AnonPages:
					goto handle_AnonPages

				case ffj_t_MemInfo_Mapped:
					goto handle_Mapped

				case ffj_t_MemInfo_Shmem:
					goto handle_Shmem

				case ffj_t_MemInfo_Slab:
					goto handle_Slab

				case ffj_t_MemInfo_SReclaimable:
					goto handle_SReclaimable

				case ffj_t_MemInfo_SUnreclaim:
					goto handle_SUnreclaim

				case ffj_t_MemInfo_KernelStack:
					goto handle_KernelStack

				case ffj_t_MemInfo_NFSUnstable:
					goto handle_NFSUnstable

				case ffj_t_MemInfo_Bounce:
					goto handle_Bounce

				case ffj_t_MemInfo_WritebackTmp:
					goto handle_WritebackTmp

				case ffj_t_MemInfo_CommitLimit:
					goto handle_CommitLimit

				case ffj_t_MemInfo_VmallocTotal:
					goto handle_VmallocTotal

				case ffj_t_MemInfo_VmallocUsed:
					goto handle_VmallocUsed

				case ffj_t_MemInfo_VmallocChunk:
					goto handle_VmallocChunk

				case ffj_t_MemInfo_HardwareCorrupted:
					goto handle_HardwareCorrupted

				case ffj_t_MemInfo_AnonHugePages:
					goto handle_AnonHugePages

				case ffj_t_MemInfo_HugePagesTotal:
					goto handle_HugePagesTotal

				case ffj_t_MemInfo_HugePagesFree:
					goto handle_HugePagesFree

				case ffj_t_MemInfo_HugePagesRsvd:
					goto handle_HugePagesRsvd

				case ffj_t_MemInfo_Hugepagesize:
					goto handle_Hugepagesize

				case ffj_t_MemInfo_DirectMap4k:
					goto handle_DirectMap4k

				case ffj_t_MemInfo_DirectMap2M:
					goto handle_DirectMap2M

				case ffj_t_MemInfono_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_MemTotal:

	/* handler: uj.MemTotal type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.MemTotal = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MemFree:

	/* handler: uj.MemFree type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.MemFree = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MemAvailable:

	/* handler: uj.MemAvailable type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.MemAvailable = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Buffers:

	/* handler: uj.Buffers type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Buffers = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Cached:

	/* handler: uj.Cached type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Cached = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_SwapCached:

	/* handler: uj.SwapCached type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.SwapCached = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Active:

	/* handler: uj.Active type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Active = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Inactive:

	/* handler: uj.Inactive type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Inactive = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ActiveAnon:

	/* handler: uj.ActiveAnon type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.ActiveAnon = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_InactiveAnon:

	/* handler: uj.InactiveAnon type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.InactiveAnon = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ActiveFile:

	/* handler: uj.ActiveFile type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.ActiveFile = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_InactiveFile:

	/* handler: uj.InactiveFile type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.InactiveFile = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Unevictable:

	/* handler: uj.Unevictable type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Unevictable = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Mlocked:

	/* handler: uj.Mlocked type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Mlocked = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_SwapTotal:

	/* handler: uj.SwapTotal type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.SwapTotal = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_SwapFree:

	/* handler: uj.SwapFree type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.SwapFree = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Dirty:

	/* handler: uj.Dirty type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Dirty = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Writeback:

	/* handler: uj.Writeback type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Writeback = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AnonPages:

	/* handler: uj.AnonPages type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.AnonPages = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Mapped:

	/* handler: uj.Mapped type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Mapped = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Shmem:

	/* handler: uj.Shmem type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Shmem = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Slab:

	/* handler: uj.Slab type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Slab = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_SReclaimable:

	/* handler: uj.SReclaimable type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.SReclaimable = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_SUnreclaim:

	/* handler: uj.SUnreclaim type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.SUnreclaim = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_KernelStack:

	/* handler: uj.KernelStack type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.KernelStack = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NFSUnstable:

	/* handler: uj.NFSUnstable type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.NFSUnstable = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Bounce:

	/* handler: uj.Bounce type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Bounce = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_WritebackTmp:

	/* handler: uj.WritebackTmp type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.WritebackTmp = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CommitLimit:

	/* handler: uj.CommitLimit type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.CommitLimit = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_VmallocTotal:

	/* handler: uj.VmallocTotal type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.VmallocTotal = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_VmallocUsed:

	/* handler: uj.VmallocUsed type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.VmallocUsed = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_VmallocChunk:

	/* handler: uj.VmallocChunk type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.VmallocChunk = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_HardwareCorrupted:

	/* handler: uj.HardwareCorrupted type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.HardwareCorrupted = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AnonHugePages:

	/* handler: uj.AnonHugePages type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.AnonHugePages = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_HugePagesTotal:

	/* handler: uj.HugePagesTotal type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.HugePagesTotal = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_HugePagesFree:

	/* handler: uj.HugePagesFree type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.HugePagesFree = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_HugePagesRsvd:

	/* handler: uj.HugePagesRsvd type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.HugePagesRsvd = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Hugepagesize:

	/* handler: uj.Hugepagesize type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Hugepagesize = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_DirectMap4k:

	/* handler: uj.DirectMap4k type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.DirectMap4k = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_DirectMap2M:

	/* handler: uj.DirectMap2M type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.DirectMap2M = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}
