// DO NOT EDIT!
// Code generated by ffjson <https://github.com/pquerna/ffjson>
// source: info.go
// DO NOT EDIT!

package ffjson

import (
	"bytes"
	"fmt"

	fflib "github.com/pquerna/ffjson/fflib/v1"
)

func (mj *ShBasicMemInfo) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *ShBasicMemInfo) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"MemTotal":`)
	fflib.FormatBits2(buf, uint64(mj.MemTotal), 10, mj.MemTotal < 0)
	buf.WriteString(`,"MemFree":`)
	fflib.FormatBits2(buf, uint64(mj.MemFree), 10, mj.MemFree < 0)
	buf.WriteString(`,"MemAvailable":`)
	fflib.FormatBits2(buf, uint64(mj.MemAvailable), 10, mj.MemAvailable < 0)
	buf.WriteString(`,"Buffers":`)
	fflib.FormatBits2(buf, uint64(mj.Buffers), 10, mj.Buffers < 0)
	buf.WriteString(`,"Cached":`)
	fflib.FormatBits2(buf, uint64(mj.Cached), 10, mj.Cached < 0)
	buf.WriteString(`,"SwapCached":`)
	fflib.FormatBits2(buf, uint64(mj.SwapCached), 10, mj.SwapCached < 0)
	buf.WriteString(`,"SwapTotal":`)
	fflib.FormatBits2(buf, uint64(mj.SwapTotal), 10, mj.SwapTotal < 0)
	buf.WriteString(`,"SwapFree":`)
	fflib.FormatBits2(buf, uint64(mj.SwapFree), 10, mj.SwapFree < 0)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_ShBasicMemInfobase = iota
	ffj_t_ShBasicMemInfono_such_key

	ffj_t_ShBasicMemInfo_MemTotal

	ffj_t_ShBasicMemInfo_MemFree

	ffj_t_ShBasicMemInfo_MemAvailable

	ffj_t_ShBasicMemInfo_Buffers

	ffj_t_ShBasicMemInfo_Cached

	ffj_t_ShBasicMemInfo_SwapCached

	ffj_t_ShBasicMemInfo_SwapTotal

	ffj_t_ShBasicMemInfo_SwapFree
)

var ffj_key_ShBasicMemInfo_MemTotal = []byte("MemTotal")

var ffj_key_ShBasicMemInfo_MemFree = []byte("MemFree")

var ffj_key_ShBasicMemInfo_MemAvailable = []byte("MemAvailable")

var ffj_key_ShBasicMemInfo_Buffers = []byte("Buffers")

var ffj_key_ShBasicMemInfo_Cached = []byte("Cached")

var ffj_key_ShBasicMemInfo_SwapCached = []byte("SwapCached")

var ffj_key_ShBasicMemInfo_SwapTotal = []byte("SwapTotal")

var ffj_key_ShBasicMemInfo_SwapFree = []byte("SwapFree")

func (uj *ShBasicMemInfo) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *ShBasicMemInfo) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_ShBasicMemInfobase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_ShBasicMemInfono_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'B':

					if bytes.Equal(ffj_key_ShBasicMemInfo_Buffers, kn) {
						currentKey = ffj_t_ShBasicMemInfo_Buffers
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'C':

					if bytes.Equal(ffj_key_ShBasicMemInfo_Cached, kn) {
						currentKey = ffj_t_ShBasicMemInfo_Cached
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'M':

					if bytes.Equal(ffj_key_ShBasicMemInfo_MemTotal, kn) {
						currentKey = ffj_t_ShBasicMemInfo_MemTotal
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ShBasicMemInfo_MemFree, kn) {
						currentKey = ffj_t_ShBasicMemInfo_MemFree
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ShBasicMemInfo_MemAvailable, kn) {
						currentKey = ffj_t_ShBasicMemInfo_MemAvailable
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'S':

					if bytes.Equal(ffj_key_ShBasicMemInfo_SwapCached, kn) {
						currentKey = ffj_t_ShBasicMemInfo_SwapCached
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ShBasicMemInfo_SwapTotal, kn) {
						currentKey = ffj_t_ShBasicMemInfo_SwapTotal
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ShBasicMemInfo_SwapFree, kn) {
						currentKey = ffj_t_ShBasicMemInfo_SwapFree
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_ShBasicMemInfo_SwapFree, kn) {
					currentKey = ffj_t_ShBasicMemInfo_SwapFree
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ShBasicMemInfo_SwapTotal, kn) {
					currentKey = ffj_t_ShBasicMemInfo_SwapTotal
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ShBasicMemInfo_SwapCached, kn) {
					currentKey = ffj_t_ShBasicMemInfo_SwapCached
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_ShBasicMemInfo_Cached, kn) {
					currentKey = ffj_t_ShBasicMemInfo_Cached
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ShBasicMemInfo_Buffers, kn) {
					currentKey = ffj_t_ShBasicMemInfo_Buffers
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_ShBasicMemInfo_MemAvailable, kn) {
					currentKey = ffj_t_ShBasicMemInfo_MemAvailable
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_ShBasicMemInfo_MemFree, kn) {
					currentKey = ffj_t_ShBasicMemInfo_MemFree
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_ShBasicMemInfo_MemTotal, kn) {
					currentKey = ffj_t_ShBasicMemInfo_MemTotal
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_ShBasicMemInfono_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_ShBasicMemInfo_MemTotal:
					goto handle_MemTotal

				case ffj_t_ShBasicMemInfo_MemFree:
					goto handle_MemFree

				case ffj_t_ShBasicMemInfo_MemAvailable:
					goto handle_MemAvailable

				case ffj_t_ShBasicMemInfo_Buffers:
					goto handle_Buffers

				case ffj_t_ShBasicMemInfo_Cached:
					goto handle_Cached

				case ffj_t_ShBasicMemInfo_SwapCached:
					goto handle_SwapCached

				case ffj_t_ShBasicMemInfo_SwapTotal:
					goto handle_SwapTotal

				case ffj_t_ShBasicMemInfo_SwapFree:
					goto handle_SwapFree

				case ffj_t_ShBasicMemInfono_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_MemTotal:

	/* handler: uj.MemTotal type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.MemTotal = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MemFree:

	/* handler: uj.MemFree type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.MemFree = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MemAvailable:

	/* handler: uj.MemAvailable type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.MemAvailable = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Buffers:

	/* handler: uj.Buffers type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Buffers = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Cached:

	/* handler: uj.Cached type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Cached = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_SwapCached:

	/* handler: uj.SwapCached type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.SwapCached = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_SwapTotal:

	/* handler: uj.SwapTotal type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.SwapTotal = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_SwapFree:

	/* handler: uj.SwapFree type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.SwapFree = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *ShMemInfo) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *ShMemInfo) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"mem_total":`)
	fflib.FormatBits2(buf, uint64(mj.MemTotal), 10, mj.MemTotal < 0)
	buf.WriteString(`,"mem_free":`)
	fflib.FormatBits2(buf, uint64(mj.MemFree), 10, mj.MemFree < 0)
	buf.WriteString(`,"mem_available":`)
	fflib.FormatBits2(buf, uint64(mj.MemAvailable), 10, mj.MemAvailable < 0)
	buf.WriteString(`,"buffers":`)
	fflib.FormatBits2(buf, uint64(mj.Buffers), 10, mj.Buffers < 0)
	buf.WriteString(`,"cached":`)
	fflib.FormatBits2(buf, uint64(mj.Cached), 10, mj.Cached < 0)
	buf.WriteString(`,"swap_cached":`)
	fflib.FormatBits2(buf, uint64(mj.SwapCached), 10, mj.SwapCached < 0)
	buf.WriteString(`,"active":`)
	fflib.FormatBits2(buf, uint64(mj.Active), 10, mj.Active < 0)
	buf.WriteString(`,"inactive":`)
	fflib.FormatBits2(buf, uint64(mj.Inactive), 10, mj.Inactive < 0)
	buf.WriteString(`,"active_anon":`)
	fflib.FormatBits2(buf, uint64(mj.ActiveAnon), 10, mj.ActiveAnon < 0)
	buf.WriteString(`,"inactive_anon":`)
	fflib.FormatBits2(buf, uint64(mj.InactiveAnon), 10, mj.InactiveAnon < 0)
	buf.WriteString(`,"active_file":`)
	fflib.FormatBits2(buf, uint64(mj.ActiveFile), 10, mj.ActiveFile < 0)
	buf.WriteString(`,"inactive_file":`)
	fflib.FormatBits2(buf, uint64(mj.InactiveFile), 10, mj.InactiveFile < 0)
	buf.WriteString(`,"unevictable":`)
	fflib.FormatBits2(buf, uint64(mj.Unevictable), 10, mj.Unevictable < 0)
	buf.WriteString(`,"mlocked":`)
	fflib.FormatBits2(buf, uint64(mj.Mlocked), 10, mj.Mlocked < 0)
	buf.WriteString(`,"swap_total":`)
	fflib.FormatBits2(buf, uint64(mj.SwapTotal), 10, mj.SwapTotal < 0)
	buf.WriteString(`,"swap_free":`)
	fflib.FormatBits2(buf, uint64(mj.SwapFree), 10, mj.SwapFree < 0)
	buf.WriteString(`,"dirty":`)
	fflib.FormatBits2(buf, uint64(mj.Dirty), 10, mj.Dirty < 0)
	buf.WriteString(`,"writeback":`)
	fflib.FormatBits2(buf, uint64(mj.Writeback), 10, mj.Writeback < 0)
	buf.WriteString(`,"anon_pages":`)
	fflib.FormatBits2(buf, uint64(mj.AnonPages), 10, mj.AnonPages < 0)
	buf.WriteString(`,"mapped":`)
	fflib.FormatBits2(buf, uint64(mj.Mapped), 10, mj.Mapped < 0)
	buf.WriteString(`,"sh_mem":`)
	fflib.FormatBits2(buf, uint64(mj.Shmem), 10, mj.Shmem < 0)
	buf.WriteString(`,"slab":`)
	fflib.FormatBits2(buf, uint64(mj.Slab), 10, mj.Slab < 0)
	buf.WriteString(`,"s_reclaimable":`)
	fflib.FormatBits2(buf, uint64(mj.SReclaimable), 10, mj.SReclaimable < 0)
	buf.WriteString(`,"s_unreclaim":`)
	fflib.FormatBits2(buf, uint64(mj.SUnreclaim), 10, mj.SUnreclaim < 0)
	buf.WriteString(`,"kernel_stack":`)
	fflib.FormatBits2(buf, uint64(mj.KernelStack), 10, mj.KernelStack < 0)
	buf.WriteString(`,"nfs_unstable":`)
	fflib.FormatBits2(buf, uint64(mj.NFSUnstable), 10, mj.NFSUnstable < 0)
	buf.WriteString(`,"bounce":`)
	fflib.FormatBits2(buf, uint64(mj.Bounce), 10, mj.Bounce < 0)
	buf.WriteString(`,"writeback_tmp":`)
	fflib.FormatBits2(buf, uint64(mj.WritebackTmp), 10, mj.WritebackTmp < 0)
	buf.WriteString(`,"commit_limit":`)
	fflib.FormatBits2(buf, uint64(mj.CommitLimit), 10, mj.CommitLimit < 0)
	buf.WriteString(`,"vmalloc_total":`)
	fflib.FormatBits2(buf, uint64(mj.VmallocTotal), 10, mj.VmallocTotal < 0)
	buf.WriteString(`,"vmalloc_used":`)
	fflib.FormatBits2(buf, uint64(mj.VmallocUsed), 10, mj.VmallocUsed < 0)
	buf.WriteString(`,"vmalloc_chunked":`)
	fflib.FormatBits2(buf, uint64(mj.VmallocChunk), 10, mj.VmallocChunk < 0)
	buf.WriteString(`,"hardware_corrupted":`)
	fflib.FormatBits2(buf, uint64(mj.HardwareCorrupted), 10, mj.HardwareCorrupted < 0)
	buf.WriteString(`,"anon_huge_pages":`)
	fflib.FormatBits2(buf, uint64(mj.AnonHugePages), 10, mj.AnonHugePages < 0)
	buf.WriteString(`,"huge_pages_total":`)
	fflib.FormatBits2(buf, uint64(mj.HugePagesTotal), 10, mj.HugePagesTotal < 0)
	buf.WriteString(`,"huge_pages_free":`)
	fflib.FormatBits2(buf, uint64(mj.HugePagesFree), 10, mj.HugePagesFree < 0)
	buf.WriteString(`,"huge_pages_rsvd":`)
	fflib.FormatBits2(buf, uint64(mj.HugePagesRsvd), 10, mj.HugePagesRsvd < 0)
	buf.WriteString(`,"huge_pages_size":`)
	fflib.FormatBits2(buf, uint64(mj.Hugepagesize), 10, mj.Hugepagesize < 0)
	buf.WriteString(`,"direct_map_4k":`)
	fflib.FormatBits2(buf, uint64(mj.DirectMap4k), 10, mj.DirectMap4k < 0)
	buf.WriteString(`,"direct_map_2m":`)
	fflib.FormatBits2(buf, uint64(mj.DirectMap2M), 10, mj.DirectMap2M < 0)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_ShMemInfobase = iota
	ffj_t_ShMemInfono_such_key

	ffj_t_ShMemInfo_MemTotal

	ffj_t_ShMemInfo_MemFree

	ffj_t_ShMemInfo_MemAvailable

	ffj_t_ShMemInfo_Buffers

	ffj_t_ShMemInfo_Cached

	ffj_t_ShMemInfo_SwapCached

	ffj_t_ShMemInfo_Active

	ffj_t_ShMemInfo_Inactive

	ffj_t_ShMemInfo_ActiveAnon

	ffj_t_ShMemInfo_InactiveAnon

	ffj_t_ShMemInfo_ActiveFile

	ffj_t_ShMemInfo_InactiveFile

	ffj_t_ShMemInfo_Unevictable

	ffj_t_ShMemInfo_Mlocked

	ffj_t_ShMemInfo_SwapTotal

	ffj_t_ShMemInfo_SwapFree

	ffj_t_ShMemInfo_Dirty

	ffj_t_ShMemInfo_Writeback

	ffj_t_ShMemInfo_AnonPages

	ffj_t_ShMemInfo_Mapped

	ffj_t_ShMemInfo_Shmem

	ffj_t_ShMemInfo_Slab

	ffj_t_ShMemInfo_SReclaimable

	ffj_t_ShMemInfo_SUnreclaim

	ffj_t_ShMemInfo_KernelStack

	ffj_t_ShMemInfo_NFSUnstable

	ffj_t_ShMemInfo_Bounce

	ffj_t_ShMemInfo_WritebackTmp

	ffj_t_ShMemInfo_CommitLimit

	ffj_t_ShMemInfo_VmallocTotal

	ffj_t_ShMemInfo_VmallocUsed

	ffj_t_ShMemInfo_VmallocChunk

	ffj_t_ShMemInfo_HardwareCorrupted

	ffj_t_ShMemInfo_AnonHugePages

	ffj_t_ShMemInfo_HugePagesTotal

	ffj_t_ShMemInfo_HugePagesFree

	ffj_t_ShMemInfo_HugePagesRsvd

	ffj_t_ShMemInfo_Hugepagesize

	ffj_t_ShMemInfo_DirectMap4k

	ffj_t_ShMemInfo_DirectMap2M
)

var ffj_key_ShMemInfo_MemTotal = []byte("mem_total")

var ffj_key_ShMemInfo_MemFree = []byte("mem_free")

var ffj_key_ShMemInfo_MemAvailable = []byte("mem_available")

var ffj_key_ShMemInfo_Buffers = []byte("buffers")

var ffj_key_ShMemInfo_Cached = []byte("cached")

var ffj_key_ShMemInfo_SwapCached = []byte("swap_cached")

var ffj_key_ShMemInfo_Active = []byte("active")

var ffj_key_ShMemInfo_Inactive = []byte("inactive")

var ffj_key_ShMemInfo_ActiveAnon = []byte("active_anon")

var ffj_key_ShMemInfo_InactiveAnon = []byte("inactive_anon")

var ffj_key_ShMemInfo_ActiveFile = []byte("active_file")

var ffj_key_ShMemInfo_InactiveFile = []byte("inactive_file")

var ffj_key_ShMemInfo_Unevictable = []byte("unevictable")

var ffj_key_ShMemInfo_Mlocked = []byte("mlocked")

var ffj_key_ShMemInfo_SwapTotal = []byte("swap_total")

var ffj_key_ShMemInfo_SwapFree = []byte("swap_free")

var ffj_key_ShMemInfo_Dirty = []byte("dirty")

var ffj_key_ShMemInfo_Writeback = []byte("writeback")

var ffj_key_ShMemInfo_AnonPages = []byte("anon_pages")

var ffj_key_ShMemInfo_Mapped = []byte("mapped")

var ffj_key_ShMemInfo_Shmem = []byte("sh_mem")

var ffj_key_ShMemInfo_Slab = []byte("slab")

var ffj_key_ShMemInfo_SReclaimable = []byte("s_reclaimable")

var ffj_key_ShMemInfo_SUnreclaim = []byte("s_unreclaim")

var ffj_key_ShMemInfo_KernelStack = []byte("kernel_stack")

var ffj_key_ShMemInfo_NFSUnstable = []byte("nfs_unstable")

var ffj_key_ShMemInfo_Bounce = []byte("bounce")

var ffj_key_ShMemInfo_WritebackTmp = []byte("writeback_tmp")

var ffj_key_ShMemInfo_CommitLimit = []byte("commit_limit")

var ffj_key_ShMemInfo_VmallocTotal = []byte("vmalloc_total")

var ffj_key_ShMemInfo_VmallocUsed = []byte("vmalloc_used")

var ffj_key_ShMemInfo_VmallocChunk = []byte("vmalloc_chunked")

var ffj_key_ShMemInfo_HardwareCorrupted = []byte("hardware_corrupted")

var ffj_key_ShMemInfo_AnonHugePages = []byte("anon_huge_pages")

var ffj_key_ShMemInfo_HugePagesTotal = []byte("huge_pages_total")

var ffj_key_ShMemInfo_HugePagesFree = []byte("huge_pages_free")

var ffj_key_ShMemInfo_HugePagesRsvd = []byte("huge_pages_rsvd")

var ffj_key_ShMemInfo_Hugepagesize = []byte("huge_pages_size")

var ffj_key_ShMemInfo_DirectMap4k = []byte("direct_map_4k")

var ffj_key_ShMemInfo_DirectMap2M = []byte("direct_map_2m")

func (uj *ShMemInfo) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *ShMemInfo) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_ShMemInfobase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_ShMemInfono_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffj_key_ShMemInfo_Active, kn) {
						currentKey = ffj_t_ShMemInfo_Active
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ShMemInfo_ActiveAnon, kn) {
						currentKey = ffj_t_ShMemInfo_ActiveAnon
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ShMemInfo_ActiveFile, kn) {
						currentKey = ffj_t_ShMemInfo_ActiveFile
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ShMemInfo_AnonPages, kn) {
						currentKey = ffj_t_ShMemInfo_AnonPages
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ShMemInfo_AnonHugePages, kn) {
						currentKey = ffj_t_ShMemInfo_AnonHugePages
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'b':

					if bytes.Equal(ffj_key_ShMemInfo_Buffers, kn) {
						currentKey = ffj_t_ShMemInfo_Buffers
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ShMemInfo_Bounce, kn) {
						currentKey = ffj_t_ShMemInfo_Bounce
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffj_key_ShMemInfo_Cached, kn) {
						currentKey = ffj_t_ShMemInfo_Cached
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ShMemInfo_CommitLimit, kn) {
						currentKey = ffj_t_ShMemInfo_CommitLimit
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffj_key_ShMemInfo_Dirty, kn) {
						currentKey = ffj_t_ShMemInfo_Dirty
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ShMemInfo_DirectMap4k, kn) {
						currentKey = ffj_t_ShMemInfo_DirectMap4k
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ShMemInfo_DirectMap2M, kn) {
						currentKey = ffj_t_ShMemInfo_DirectMap2M
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'h':

					if bytes.Equal(ffj_key_ShMemInfo_HardwareCorrupted, kn) {
						currentKey = ffj_t_ShMemInfo_HardwareCorrupted
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ShMemInfo_HugePagesTotal, kn) {
						currentKey = ffj_t_ShMemInfo_HugePagesTotal
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ShMemInfo_HugePagesFree, kn) {
						currentKey = ffj_t_ShMemInfo_HugePagesFree
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ShMemInfo_HugePagesRsvd, kn) {
						currentKey = ffj_t_ShMemInfo_HugePagesRsvd
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ShMemInfo_Hugepagesize, kn) {
						currentKey = ffj_t_ShMemInfo_Hugepagesize
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffj_key_ShMemInfo_Inactive, kn) {
						currentKey = ffj_t_ShMemInfo_Inactive
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ShMemInfo_InactiveAnon, kn) {
						currentKey = ffj_t_ShMemInfo_InactiveAnon
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ShMemInfo_InactiveFile, kn) {
						currentKey = ffj_t_ShMemInfo_InactiveFile
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'k':

					if bytes.Equal(ffj_key_ShMemInfo_KernelStack, kn) {
						currentKey = ffj_t_ShMemInfo_KernelStack
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffj_key_ShMemInfo_MemTotal, kn) {
						currentKey = ffj_t_ShMemInfo_MemTotal
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ShMemInfo_MemFree, kn) {
						currentKey = ffj_t_ShMemInfo_MemFree
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ShMemInfo_MemAvailable, kn) {
						currentKey = ffj_t_ShMemInfo_MemAvailable
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ShMemInfo_Mlocked, kn) {
						currentKey = ffj_t_ShMemInfo_Mlocked
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ShMemInfo_Mapped, kn) {
						currentKey = ffj_t_ShMemInfo_Mapped
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'n':

					if bytes.Equal(ffj_key_ShMemInfo_NFSUnstable, kn) {
						currentKey = ffj_t_ShMemInfo_NFSUnstable
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffj_key_ShMemInfo_SwapCached, kn) {
						currentKey = ffj_t_ShMemInfo_SwapCached
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ShMemInfo_SwapTotal, kn) {
						currentKey = ffj_t_ShMemInfo_SwapTotal
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ShMemInfo_SwapFree, kn) {
						currentKey = ffj_t_ShMemInfo_SwapFree
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ShMemInfo_Shmem, kn) {
						currentKey = ffj_t_ShMemInfo_Shmem
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ShMemInfo_Slab, kn) {
						currentKey = ffj_t_ShMemInfo_Slab
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ShMemInfo_SReclaimable, kn) {
						currentKey = ffj_t_ShMemInfo_SReclaimable
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ShMemInfo_SUnreclaim, kn) {
						currentKey = ffj_t_ShMemInfo_SUnreclaim
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffj_key_ShMemInfo_Unevictable, kn) {
						currentKey = ffj_t_ShMemInfo_Unevictable
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'v':

					if bytes.Equal(ffj_key_ShMemInfo_VmallocTotal, kn) {
						currentKey = ffj_t_ShMemInfo_VmallocTotal
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ShMemInfo_VmallocUsed, kn) {
						currentKey = ffj_t_ShMemInfo_VmallocUsed
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ShMemInfo_VmallocChunk, kn) {
						currentKey = ffj_t_ShMemInfo_VmallocChunk
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'w':

					if bytes.Equal(ffj_key_ShMemInfo_Writeback, kn) {
						currentKey = ffj_t_ShMemInfo_Writeback
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ShMemInfo_WritebackTmp, kn) {
						currentKey = ffj_t_ShMemInfo_WritebackTmp
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.AsciiEqualFold(ffj_key_ShMemInfo_DirectMap2M, kn) {
					currentKey = ffj_t_ShMemInfo_DirectMap2M
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ShMemInfo_DirectMap4k, kn) {
					currentKey = ffj_t_ShMemInfo_DirectMap4k
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ShMemInfo_Hugepagesize, kn) {
					currentKey = ffj_t_ShMemInfo_Hugepagesize
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ShMemInfo_HugePagesRsvd, kn) {
					currentKey = ffj_t_ShMemInfo_HugePagesRsvd
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ShMemInfo_HugePagesFree, kn) {
					currentKey = ffj_t_ShMemInfo_HugePagesFree
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ShMemInfo_HugePagesTotal, kn) {
					currentKey = ffj_t_ShMemInfo_HugePagesTotal
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ShMemInfo_AnonHugePages, kn) {
					currentKey = ffj_t_ShMemInfo_AnonHugePages
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_ShMemInfo_HardwareCorrupted, kn) {
					currentKey = ffj_t_ShMemInfo_HardwareCorrupted
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ShMemInfo_VmallocChunk, kn) {
					currentKey = ffj_t_ShMemInfo_VmallocChunk
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ShMemInfo_VmallocUsed, kn) {
					currentKey = ffj_t_ShMemInfo_VmallocUsed
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_ShMemInfo_VmallocTotal, kn) {
					currentKey = ffj_t_ShMemInfo_VmallocTotal
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_ShMemInfo_CommitLimit, kn) {
					currentKey = ffj_t_ShMemInfo_CommitLimit
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ShMemInfo_WritebackTmp, kn) {
					currentKey = ffj_t_ShMemInfo_WritebackTmp
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_ShMemInfo_Bounce, kn) {
					currentKey = ffj_t_ShMemInfo_Bounce
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ShMemInfo_NFSUnstable, kn) {
					currentKey = ffj_t_ShMemInfo_NFSUnstable
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ShMemInfo_KernelStack, kn) {
					currentKey = ffj_t_ShMemInfo_KernelStack
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ShMemInfo_SUnreclaim, kn) {
					currentKey = ffj_t_ShMemInfo_SUnreclaim
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ShMemInfo_SReclaimable, kn) {
					currentKey = ffj_t_ShMemInfo_SReclaimable
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ShMemInfo_Slab, kn) {
					currentKey = ffj_t_ShMemInfo_Slab
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ShMemInfo_Shmem, kn) {
					currentKey = ffj_t_ShMemInfo_Shmem
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_ShMemInfo_Mapped, kn) {
					currentKey = ffj_t_ShMemInfo_Mapped
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ShMemInfo_AnonPages, kn) {
					currentKey = ffj_t_ShMemInfo_AnonPages
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ShMemInfo_Writeback, kn) {
					currentKey = ffj_t_ShMemInfo_Writeback
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_ShMemInfo_Dirty, kn) {
					currentKey = ffj_t_ShMemInfo_Dirty
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ShMemInfo_SwapFree, kn) {
					currentKey = ffj_t_ShMemInfo_SwapFree
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ShMemInfo_SwapTotal, kn) {
					currentKey = ffj_t_ShMemInfo_SwapTotal
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ShMemInfo_Mlocked, kn) {
					currentKey = ffj_t_ShMemInfo_Mlocked
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_ShMemInfo_Unevictable, kn) {
					currentKey = ffj_t_ShMemInfo_Unevictable
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_ShMemInfo_InactiveFile, kn) {
					currentKey = ffj_t_ShMemInfo_InactiveFile
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_ShMemInfo_ActiveFile, kn) {
					currentKey = ffj_t_ShMemInfo_ActiveFile
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_ShMemInfo_InactiveAnon, kn) {
					currentKey = ffj_t_ShMemInfo_InactiveAnon
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_ShMemInfo_ActiveAnon, kn) {
					currentKey = ffj_t_ShMemInfo_ActiveAnon
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_ShMemInfo_Inactive, kn) {
					currentKey = ffj_t_ShMemInfo_Inactive
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_ShMemInfo_Active, kn) {
					currentKey = ffj_t_ShMemInfo_Active
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ShMemInfo_SwapCached, kn) {
					currentKey = ffj_t_ShMemInfo_SwapCached
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_ShMemInfo_Cached, kn) {
					currentKey = ffj_t_ShMemInfo_Cached
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ShMemInfo_Buffers, kn) {
					currentKey = ffj_t_ShMemInfo_Buffers
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_ShMemInfo_MemAvailable, kn) {
					currentKey = ffj_t_ShMemInfo_MemAvailable
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_ShMemInfo_MemFree, kn) {
					currentKey = ffj_t_ShMemInfo_MemFree
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_ShMemInfo_MemTotal, kn) {
					currentKey = ffj_t_ShMemInfo_MemTotal
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_ShMemInfono_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_ShMemInfo_MemTotal:
					goto handle_MemTotal

				case ffj_t_ShMemInfo_MemFree:
					goto handle_MemFree

				case ffj_t_ShMemInfo_MemAvailable:
					goto handle_MemAvailable

				case ffj_t_ShMemInfo_Buffers:
					goto handle_Buffers

				case ffj_t_ShMemInfo_Cached:
					goto handle_Cached

				case ffj_t_ShMemInfo_SwapCached:
					goto handle_SwapCached

				case ffj_t_ShMemInfo_Active:
					goto handle_Active

				case ffj_t_ShMemInfo_Inactive:
					goto handle_Inactive

				case ffj_t_ShMemInfo_ActiveAnon:
					goto handle_ActiveAnon

				case ffj_t_ShMemInfo_InactiveAnon:
					goto handle_InactiveAnon

				case ffj_t_ShMemInfo_ActiveFile:
					goto handle_ActiveFile

				case ffj_t_ShMemInfo_InactiveFile:
					goto handle_InactiveFile

				case ffj_t_ShMemInfo_Unevictable:
					goto handle_Unevictable

				case ffj_t_ShMemInfo_Mlocked:
					goto handle_Mlocked

				case ffj_t_ShMemInfo_SwapTotal:
					goto handle_SwapTotal

				case ffj_t_ShMemInfo_SwapFree:
					goto handle_SwapFree

				case ffj_t_ShMemInfo_Dirty:
					goto handle_Dirty

				case ffj_t_ShMemInfo_Writeback:
					goto handle_Writeback

				case ffj_t_ShMemInfo_AnonPages:
					goto handle_AnonPages

				case ffj_t_ShMemInfo_Mapped:
					goto handle_Mapped

				case ffj_t_ShMemInfo_Shmem:
					goto handle_Shmem

				case ffj_t_ShMemInfo_Slab:
					goto handle_Slab

				case ffj_t_ShMemInfo_SReclaimable:
					goto handle_SReclaimable

				case ffj_t_ShMemInfo_SUnreclaim:
					goto handle_SUnreclaim

				case ffj_t_ShMemInfo_KernelStack:
					goto handle_KernelStack

				case ffj_t_ShMemInfo_NFSUnstable:
					goto handle_NFSUnstable

				case ffj_t_ShMemInfo_Bounce:
					goto handle_Bounce

				case ffj_t_ShMemInfo_WritebackTmp:
					goto handle_WritebackTmp

				case ffj_t_ShMemInfo_CommitLimit:
					goto handle_CommitLimit

				case ffj_t_ShMemInfo_VmallocTotal:
					goto handle_VmallocTotal

				case ffj_t_ShMemInfo_VmallocUsed:
					goto handle_VmallocUsed

				case ffj_t_ShMemInfo_VmallocChunk:
					goto handle_VmallocChunk

				case ffj_t_ShMemInfo_HardwareCorrupted:
					goto handle_HardwareCorrupted

				case ffj_t_ShMemInfo_AnonHugePages:
					goto handle_AnonHugePages

				case ffj_t_ShMemInfo_HugePagesTotal:
					goto handle_HugePagesTotal

				case ffj_t_ShMemInfo_HugePagesFree:
					goto handle_HugePagesFree

				case ffj_t_ShMemInfo_HugePagesRsvd:
					goto handle_HugePagesRsvd

				case ffj_t_ShMemInfo_Hugepagesize:
					goto handle_Hugepagesize

				case ffj_t_ShMemInfo_DirectMap4k:
					goto handle_DirectMap4k

				case ffj_t_ShMemInfo_DirectMap2M:
					goto handle_DirectMap2M

				case ffj_t_ShMemInfono_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_MemTotal:

	/* handler: uj.MemTotal type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.MemTotal = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MemFree:

	/* handler: uj.MemFree type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.MemFree = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MemAvailable:

	/* handler: uj.MemAvailable type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.MemAvailable = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Buffers:

	/* handler: uj.Buffers type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Buffers = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Cached:

	/* handler: uj.Cached type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Cached = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_SwapCached:

	/* handler: uj.SwapCached type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.SwapCached = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Active:

	/* handler: uj.Active type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Active = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Inactive:

	/* handler: uj.Inactive type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Inactive = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ActiveAnon:

	/* handler: uj.ActiveAnon type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.ActiveAnon = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_InactiveAnon:

	/* handler: uj.InactiveAnon type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.InactiveAnon = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ActiveFile:

	/* handler: uj.ActiveFile type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.ActiveFile = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_InactiveFile:

	/* handler: uj.InactiveFile type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.InactiveFile = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Unevictable:

	/* handler: uj.Unevictable type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Unevictable = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Mlocked:

	/* handler: uj.Mlocked type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Mlocked = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_SwapTotal:

	/* handler: uj.SwapTotal type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.SwapTotal = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_SwapFree:

	/* handler: uj.SwapFree type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.SwapFree = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Dirty:

	/* handler: uj.Dirty type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Dirty = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Writeback:

	/* handler: uj.Writeback type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Writeback = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AnonPages:

	/* handler: uj.AnonPages type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.AnonPages = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Mapped:

	/* handler: uj.Mapped type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Mapped = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Shmem:

	/* handler: uj.Shmem type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Shmem = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Slab:

	/* handler: uj.Slab type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Slab = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_SReclaimable:

	/* handler: uj.SReclaimable type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.SReclaimable = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_SUnreclaim:

	/* handler: uj.SUnreclaim type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.SUnreclaim = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_KernelStack:

	/* handler: uj.KernelStack type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.KernelStack = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NFSUnstable:

	/* handler: uj.NFSUnstable type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.NFSUnstable = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Bounce:

	/* handler: uj.Bounce type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Bounce = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_WritebackTmp:

	/* handler: uj.WritebackTmp type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.WritebackTmp = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CommitLimit:

	/* handler: uj.CommitLimit type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.CommitLimit = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_VmallocTotal:

	/* handler: uj.VmallocTotal type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.VmallocTotal = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_VmallocUsed:

	/* handler: uj.VmallocUsed type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.VmallocUsed = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_VmallocChunk:

	/* handler: uj.VmallocChunk type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.VmallocChunk = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_HardwareCorrupted:

	/* handler: uj.HardwareCorrupted type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.HardwareCorrupted = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AnonHugePages:

	/* handler: uj.AnonHugePages type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.AnonHugePages = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_HugePagesTotal:

	/* handler: uj.HugePagesTotal type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.HugePagesTotal = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_HugePagesFree:

	/* handler: uj.HugePagesFree type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.HugePagesFree = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_HugePagesRsvd:

	/* handler: uj.HugePagesRsvd type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.HugePagesRsvd = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Hugepagesize:

	/* handler: uj.Hugepagesize type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Hugepagesize = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_DirectMap4k:

	/* handler: uj.DirectMap4k type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.DirectMap4k = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_DirectMap2M:

	/* handler: uj.DirectMap2M type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.DirectMap2M = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}
